/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/zoubingwu/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
import { HttpResponse, http } from "msw";
import { faker } from "@faker-js/faker";
import { setupServer } from "msw/node";

faker.seed(1);

const baseURL = "";
const MAX_ARRAY_LENGTH = 20;

let i = 0;
const next = () => {
  if (i === Number.MAX_SAFE_INTEGER - 1) {
    i = 0;
  }
  return i++;
};

export const handlers = [
  http.get(`${baseURL}/api/v1/activity/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/albums/`, () => {
    const resultArray = [[getGetAlbums200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/albums/`, () => {
    const resultArray = [[getCreateAlbum201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/albums/:id/`, () => {
    const resultArray = [[getGetAlbum200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/albums/:id/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/albums/:id/fetches/`, () => {
    const resultArray = [[getGetAlbumFetches200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/albums/:id/fetches/`, () => {
    const resultArray = [[getCreateAlbumFetch200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/albums/:id/libraries/`, () => {
    const resultArray = [[getGetAlbumLibraries200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/albums/:id/mutations/`, () => {
    const resultArray = [[getGetAlbumMutations200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/albums/:id/mutations/`, () => {
    const resultArray = [
      [getCreateAlbumMutation200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/artists/`, () => {
    const resultArray = [[getGetArtists200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/artists/:id/`, () => {
    const resultArray = [[getGetArtist200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/artists/:id/fetches/`, () => {
    const resultArray = [[getGetArtistFetches200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/artists/:id/fetches/`, () => {
    const resultArray = [[getCreateArtistFetch200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/artists/:id/libraries/`, () => {
    const resultArray = [[getGetArtistLibraries200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/artists/:id/mutations/`, () => {
    const resultArray = [[getGetArtistMutations200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/artists/:id/mutations/`, () => {
    const resultArray = [
      [getCreateArtistMutation200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/attachments/`, () => {
    const resultArray = [[getCreateAttachment201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/attachments/:uuid/`, () => {
    const resultArray = [[getGetAttachment200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/attachments/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/attachments/:uuid/proxy/`, () => {
    const resultArray = [[getGetAttachmentProxy200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/auth/password/change/`, () => {
    const resultArray = [[getChangePassword200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/auth/password/reset/`, () => {
    const resultArray = [[getResetPassword200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/auth/password/reset/confirm/`, () => {
    const resultArray = [
      [getConfirmPasswordReset200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/auth/registration/`, () => {
    const resultArray = [[getRegister201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/auth/registration/change-password/`, () => {
    const resultArray = [[getChangePassword2200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/auth/registration/verify-email/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/auth/user/`, () => {
    const resultArray = [[getGetAuthUser200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/auth/user/`, () => {
    const resultArray = [[getUpdateAuthUser200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/auth/user/`, () => {
    const resultArray = [
      [getPartialUpdateAuthUser200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/channels/`, () => {
    const resultArray = [[getGetChannels200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/channels/`, () => {
    const resultArray = [[getCreateChannel201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/channels/:composite/`, () => {
    const resultArray = [[getGetChannel200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/channels/:composite/`, () => {
    const resultArray = [[getUpdateChannel200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/channels/:composite/`, () => {
    const resultArray = [
      [getPartialUpdateChannel200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/channels/:composite/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/channels/:composite/rss/`, () => {
    const resultArray = [[getGetChannelRss200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/channels/:composite/subscribe/`, () => {
    const resultArray = [[getSubscribeChannel200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/channels/:composite/unsubscribe/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/channels/:composite/unsubscribe/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/channels/metadata-choices/`, () => {
    const resultArray = [
      [getGetChannelMetadataChoices200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/channels/rss-subscribe/`, () => {
    const resultArray = [
      [getSubscribeChannelRss200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/favorites/tracks/`, () => {
    const resultArray = [[getGetFavoriteTracks200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/favorites/tracks/`, () => {
    const resultArray = [[getFavoriteTrack201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/favorites/tracks/:id/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/favorites/tracks/all/`, () => {
    const resultArray = [
      [getGetAllFavoriteTracks200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/favorites/tracks/remove/`, () => {
    const resultArray = [[getUnfavoriteTrack2200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/favorites/tracks/remove/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/federation/actors/:fullUsername/`, () => {
    const resultArray = [[getGetFederationActor200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(
    `${baseURL}/api/v1/federation/actors/:fullUsername/libraries/`,
    () => {
      const resultArray = [
        [getGetFederationActorLibrary200Response(), { status: 200 }],
      ];

      return HttpResponse.json(...resultArray[next() % resultArray.length]);
    },
  ),
  http.get(`${baseURL}/api/v1/federation/domains/`, () => {
    const resultArray = [
      [getGetFederationDomains200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/federation/domains/:name/`, () => {
    const resultArray = [
      [getGetFederationDomain200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/federation/fetches/`, () => {
    const resultArray = [
      [getCreateFederationFetch201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/federation/fetches/:id/`, () => {
    const resultArray = [[getGetFederationFetch200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/federation/follows/library/`, () => {
    const resultArray = [
      [getGetFederationLibraryFollows200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/federation/follows/library/`, () => {
    const resultArray = [
      [getCreateFederationLibraryFollow201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/federation/follows/library/:uuid/`, () => {
    const resultArray = [
      [getGetFederationLibraryFollow200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/federation/follows/library/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(
    `${baseURL}/api/v1/federation/follows/library/:uuid/accept/`,
    () => {
      const resultArray = [
        [null, { status: 204 }],
        [null, { status: 404 }],
      ];

      return HttpResponse.json(...resultArray[next() % resultArray.length]);
    },
  ),
  http.post(
    `${baseURL}/api/v1/federation/follows/library/:uuid/reject/`,
    () => {
      const resultArray = [
        [getRejectFederationLibraryFollow200Response(), { status: 200 }],
      ];

      return HttpResponse.json(...resultArray[next() % resultArray.length]);
    },
  ),
  http.get(`${baseURL}/api/v1/federation/follows/library/all/`, () => {
    const resultArray = [
      [getGetAllFederationLibraryFollows200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/federation/inbox/`, () => {
    const resultArray = [
      [getGetFederationInboxes200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/federation/inbox/:id/`, () => {
    const resultArray = [[getGetFederationInbox200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/federation/inbox/:id/`, () => {
    const resultArray = [
      [getUpdateFederationInbox200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/federation/inbox/:id/`, () => {
    const resultArray = [
      [getPartialUpdateFederationInbox200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/federation/inbox/action/`, () => {
    const resultArray = [
      [getCreateFederationInboxAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/federation/libraries/:uuid/`, () => {
    const resultArray = [
      [getGetFederationLibrary200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/federation/libraries/:uuid/scan/`, () => {
    const resultArray = [
      [getCreateFederationLibraryScan200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/federation/libraries/fetch/`, () => {
    const resultArray = [
      [getCreateFederationLibraryFetch200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/history/listenings/`, () => {
    const resultArray = [
      [getGetHistoryListenings200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/history/listenings/`, () => {
    const resultArray = [
      [getCreateHistoryListening201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/history/listenings/:id/`, () => {
    const resultArray = [
      [getGetHistoryListening200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/instance/admin/settings/`, () => {
    const resultArray = [
      [getGetInstanceAdminSettings200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/instance/admin/settings/:id/`, () => {
    const resultArray = [
      [getGetInstanceAdminSetting200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/instance/admin/settings/:id/`, () => {
    const resultArray = [
      [getUpdateInstanceAdminSetting200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/instance/admin/settings/:id/`, () => {
    const resultArray = [
      [getPartialUpdateInstanceAdminSetting200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/instance/admin/settings/bulk/`, () => {
    const resultArray = [
      [getCreateInstanceAdminSettingBulk200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/instance/nodeinfo/2.0/`, () => {
    const resultArray = [[getGetNodeInfo20200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/instance/settings/`, () => {
    const resultArray = [
      [getGetInstanceSettings200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/instance/spa-manifest.json`, () => {
    const resultArray = [[getGetSpaManifest200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/libraries/`, () => {
    const resultArray = [[getGetLibraries200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/libraries/`, () => {
    const resultArray = [[getCreateLibrary201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/libraries/:uuid/`, () => {
    const resultArray = [[getGetLibrary200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/libraries/:uuid/`, () => {
    const resultArray = [[getUpdateLibrary200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/libraries/:uuid/`, () => {
    const resultArray = [
      [getPartialUpdateLibrary200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/libraries/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/libraries/:uuid/follows/`, () => {
    const resultArray = [[getGetLibraryFollows200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/libraries/fs-import/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/libraries/fs-import/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/libraries/fs-import/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/licenses/`, () => {
    const resultArray = [[getGetLicenses200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/licenses/:code/`, () => {
    const resultArray = [[getGetLicense200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/listen/:uuid/`, () => {
    const resultArray = [[getGetListen200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/accounts/`, () => {
    const resultArray = [[getAdminGetAccounts200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/accounts/:id/`, () => {
    const resultArray = [[getAdminGetAccount200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/accounts/:id/stats/`, () => {
    const resultArray = [
      [getAdminGetAccountStats200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/accounts/action/`, () => {
    const resultArray = [
      [getAdminCreateAccountAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/channels/`, () => {
    const resultArray = [[getAdminGetChannels200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/channels/:composite/`, () => {
    const resultArray = [[getAdminGetChannel200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/manage/channels/:composite/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/channels/:composite/stats/`, () => {
    const resultArray = [
      [getAdminGetChannelStats200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/federation/domains/`, () => {
    const resultArray = [
      [getAdminGetFederationDomains200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/federation/domains/`, () => {
    const resultArray = [
      [getAdminCreateFederationDomain201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/federation/domains/:name/`, () => {
    const resultArray = [
      [getAdminGetFederationDomain200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/manage/federation/domains/:name/`, () => {
    const resultArray = [
      [getAdminUpdateFederationDomain200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/manage/federation/domains/:name/`, () => {
    const resultArray = [
      [getAdminPartialUpdateFederationDomain200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(
    `${baseURL}/api/v1/manage/federation/domains/:name/nodeinfo/`,
    () => {
      const resultArray = [
        [getAdminGetFederationDomainNodeinfo200Response(), { status: 200 }],
      ];

      return HttpResponse.json(...resultArray[next() % resultArray.length]);
    },
  ),
  http.get(`${baseURL}/api/v1/manage/federation/domains/:name/stats/`, () => {
    const resultArray = [
      [getAdminGetFederationDomainStats200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/federation/domains/action/`, () => {
    const resultArray = [
      [getAdminCreateFederationDomainAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/albums/`, () => {
    const resultArray = [[getAdminGetAlbums200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/albums/:id/`, () => {
    const resultArray = [[getAdminGetAlbum200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/manage/library/albums/:id/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/albums/:id/stats/`, () => {
    const resultArray = [
      [getAdminGetLibraryAlbumStats200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/library/albums/action/`, () => {
    const resultArray = [
      [getAdminCreateAlbumAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/artists/`, () => {
    const resultArray = [[getAdminGetArtists200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/artists/:id/`, () => {
    const resultArray = [[getAdminGetArtist200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/manage/library/artists/:id/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/artists/:id/stats/`, () => {
    const resultArray = [
      [getAdminGetLibraryArtistStats200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/library/artists/action/`, () => {
    const resultArray = [
      [getAdminCreateArtistAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/libraries/`, () => {
    const resultArray = [[getAdminGetLibraries200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/libraries/:uuid/`, () => {
    const resultArray = [[getAdminGetLibrary200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/manage/library/libraries/:uuid/`, () => {
    const resultArray = [[getAdminUpdateLibrary200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/manage/library/libraries/:uuid/`, () => {
    const resultArray = [
      [getAdminPartialUpdateLibrary200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/manage/library/libraries/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/libraries/:uuid/stats/`, () => {
    const resultArray = [
      [getAdminGetLibraryStats200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/library/libraries/action/`, () => {
    const resultArray = [
      [getAdminCreateLibraryAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/tracks/`, () => {
    const resultArray = [[getAdminGetTracks200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/tracks/:id/`, () => {
    const resultArray = [[getAdminGetTrack200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/manage/library/tracks/:id/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/tracks/:id/stats/`, () => {
    const resultArray = [[getAdminGetTrackStats200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/library/tracks/action/`, () => {
    const resultArray = [
      [getAdminCreateTrackAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/uploads/`, () => {
    const resultArray = [[getAdminGetUploads200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/library/uploads/:uuid/`, () => {
    const resultArray = [[getAdminGetUpload200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/manage/library/uploads/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/library/uploads/action/`, () => {
    const resultArray = [
      [getAdminCreateUploadAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/moderation/instance-policies/`, () => {
    const resultArray = [
      [getModerationGetInstancePolicies200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/moderation/instance-policies/`, () => {
    const resultArray = [
      [getModerationCreateInstancePolicy201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/moderation/instance-policies/:id/`, () => {
    const resultArray = [
      [getModerationGetInstancePolicy200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/manage/moderation/instance-policies/:id/`, () => {
    const resultArray = [
      [getModerationUpdateInstancePolicy200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(
    `${baseURL}/api/v1/manage/moderation/instance-policies/:id/`,
    () => {
      const resultArray = [
        [
          getModerationPartialUpdateInstancePolicy200Response(),
          { status: 200 },
        ],
      ];

      return HttpResponse.json(...resultArray[next() % resultArray.length]);
    },
  ),
  http.delete(
    `${baseURL}/api/v1/manage/moderation/instance-policies/:id/`,
    () => {
      const resultArray = [[null, { status: 204 }]];

      return HttpResponse.json(...resultArray[next() % resultArray.length]);
    },
  ),
  http.get(`${baseURL}/api/v1/manage/moderation/notes/`, () => {
    const resultArray = [[getModerationGetNotes200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/moderation/notes/`, () => {
    const resultArray = [
      [getModerationCreateNote201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/moderation/notes/:uuid/`, () => {
    const resultArray = [[getModerationGetNote200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/manage/moderation/notes/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/moderation/reports/`, () => {
    const resultArray = [
      [getModerationGetReports200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/moderation/reports/:uuid/`, () => {
    const resultArray = [
      [getModerationGetReport200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/manage/moderation/reports/:uuid/`, () => {
    const resultArray = [
      [getModerationUpdateReport200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/manage/moderation/reports/:uuid/`, () => {
    const resultArray = [
      [getModerationPartialUpdateReport200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/moderation/requests/`, () => {
    const resultArray = [
      [getModerationGetRequests200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/moderation/requests/:uuid/`, () => {
    const resultArray = [
      [getModerationGetRequest200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/manage/moderation/requests/:uuid/`, () => {
    const resultArray = [
      [getModerationUpdateRequest200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/manage/moderation/requests/:uuid/`, () => {
    const resultArray = [
      [getModerationPartialUpdateRequest200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/tags/`, () => {
    const resultArray = [[getAdminGetTags200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/tags/`, () => {
    const resultArray = [[getAdminCreateTag201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/tags/:name/`, () => {
    const resultArray = [[getAdminGetTag200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/manage/tags/:name/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/tags/action/`, () => {
    const resultArray = [
      [getAdminCreateTagAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/users/invitations/`, () => {
    const resultArray = [
      [getAdminGetInvitations200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/users/invitations/`, () => {
    const resultArray = [
      [getAdminCreateInvitation201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/users/invitations/:id/`, () => {
    const resultArray = [[getAdminGetInvitation200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/manage/users/invitations/:id/`, () => {
    const resultArray = [
      [getAdminUpdateInvitation200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/manage/users/invitations/:id/`, () => {
    const resultArray = [
      [getAdminPartialUpdateInvitation200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/manage/users/invitations/action/`, () => {
    const resultArray = [
      [getAdminCreateInvitationAction200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/users/users/`, () => {
    const resultArray = [[getAdminGetUsers200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/manage/users/users/:id/`, () => {
    const resultArray = [[getAdminGetUser200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/manage/users/users/:id/`, () => {
    const resultArray = [[getAdminUpdateUser200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/manage/users/users/:id/`, () => {
    const resultArray = [
      [getAdminPartialUpdateUser200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/moderation/content-filters/`, () => {
    const resultArray = [
      [getGetModerationContentFilters200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/moderation/content-filters/`, () => {
    const resultArray = [
      [getCreateModerationContentFilter201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/moderation/content-filters/:uuid/`, () => {
    const resultArray = [
      [getGetModerationContentFilter200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/moderation/content-filters/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/moderation/reports/`, () => {
    const resultArray = [
      [getCreateModerationReport201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/mutations/`, () => {
    const resultArray = [[getGetMutations200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/mutations/:uuid/`, () => {
    const resultArray = [[getGetMutation200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/mutations/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/mutations/:uuid/approve/`, () => {
    const resultArray = [[getApproveMutation200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/mutations/:uuid/reject/`, () => {
    const resultArray = [[getRejectMutation200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/oauth/apps/`, () => {
    const resultArray = [[getGetOauthApps200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/oauth/apps/`, () => {
    const resultArray = [[getCreateOauthApp201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/oauth/apps/:clientId/`, () => {
    const resultArray = [[getGetOauthApp200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/oauth/apps/:clientId/`, () => {
    const resultArray = [[getUpdateOauthApp200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/oauth/apps/:clientId/`, () => {
    const resultArray = [
      [getPartialUpdateOauthApp200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/oauth/apps/:clientId/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/oauth/apps/:clientId/refresh-token/`, () => {
    const resultArray = [[getRefreshOauthToken200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/oauth/grants/`, () => {
    const resultArray = [[getGetOauthGrants200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/oauth/grants/:clientId/`, () => {
    const resultArray = [[getGetOauthGrant200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/oauth/grants/:clientId/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/oembed/`, () => {
    const resultArray = [[getGetOembed200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/playlists/`, () => {
    const resultArray = [[getGetPlaylists200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/playlists/`, () => {
    const resultArray = [[getCreatePlaylist201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/playlists/:id/`, () => {
    const resultArray = [[getGetPlaylist200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/playlists/:id/`, () => {
    const resultArray = [[getUpdatePlaylist200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/playlists/:id/`, () => {
    const resultArray = [
      [getPartialUpdatePlaylist200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/playlists/:id/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/playlists/:id/add/`, () => {
    const resultArray = [[getAddToPlaylist200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/playlists/:id/clear/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/playlists/:id/move/`, () => {
    const resultArray = [
      [getReorderTrackInPlaylist200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/playlists/:id/remove/`, () => {
    const resultArray = [
      [getRemoveFromPlaylist2200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/playlists/:id/remove/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/playlists/:id/tracks/`, () => {
    const resultArray = [[getGetPlaylistTracks200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/plugins/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/plugins/`, () => {
    const resultArray = [[null, { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/plugins/:id/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/plugins/:id/disable/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/plugins/:id/enable/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/plugins/:id/scan/`, () => {
    const resultArray = [[null, { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/radios/radios/`, () => {
    const resultArray = [[getGetRadios200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/radios/radios/`, () => {
    const resultArray = [[getCreateRadio201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/radios/radios/:id/`, () => {
    const resultArray = [[getGetRadio200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/radios/radios/:id/`, () => {
    const resultArray = [[getUpdateRadio200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/radios/radios/:id/`, () => {
    const resultArray = [[getPartialUpdateRadio200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/radios/radios/:id/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/radios/radios/:id/tracks/`, () => {
    const resultArray = [[getGetRadioTrack200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/radios/radios/filters/`, () => {
    const resultArray = [[getGetRadioFilter200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/radios/radios/validate/`, () => {
    const resultArray = [[getValidateRadio200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/radios/sessions/`, () => {
    const resultArray = [[getCreateRadioSession201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/radios/sessions/:id/`, () => {
    const resultArray = [[getGetRadioSession200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/radios/tracks/`, () => {
    const resultArray = [[getGetNextRadioTrack201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/rate-limit/`, () => {
    const resultArray = [[getGetRateLimit200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/search`, () => {
    const resultArray = [[getGetSearchResults200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/stream/:uuid/`, () => {
    const resultArray = [[getGetTrackStream200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/subscriptions/`, () => {
    const resultArray = [[getGetSubscriptions200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/subscriptions/:uuid/`, () => {
    const resultArray = [[getGetSubscription200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/subscriptions/all/`, () => {
    const resultArray = [
      [getGetAllSubscriptions200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/tags/`, () => {
    const resultArray = [[getGetTags200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/tags/:name/`, () => {
    const resultArray = [[getGetTag200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/text-preview/`, () => {
    const resultArray = [
      [getPreviewText200Response(), { status: 200 }],
      [getPreviewText400Response(), { status: 400 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/tracks/`, () => {
    const resultArray = [[getGetTracks200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/tracks/:id/`, () => {
    const resultArray = [[getGetTrack200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/tracks/:id/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/tracks/:id/fetches/`, () => {
    const resultArray = [[getGetTrackFetches200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/tracks/:id/fetches/`, () => {
    const resultArray = [[getCreateTrackFetch200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/tracks/:id/libraries/`, () => {
    const resultArray = [[getGetTrackLibraries200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/tracks/:id/mutations/`, () => {
    const resultArray = [[getGetTrackMutations200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/tracks/:id/mutations/`, () => {
    const resultArray = [
      [getCreateTrackMutation200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/uploads/`, () => {
    const resultArray = [[getGetUploads200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/uploads/`, () => {
    const resultArray = [[getCreateUpload201Response(), { status: 201 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/uploads/:uuid/`, () => {
    const resultArray = [[getGetUpload200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/uploads/:uuid/`, () => {
    const resultArray = [[getUpdateUpload200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/uploads/:uuid/`, () => {
    const resultArray = [
      [getPartialUpdateUpload200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/uploads/:uuid/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/uploads/:uuid/audio-file-metadata/`, () => {
    const resultArray = [[getGetUploadMetadata200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/uploads/action/`, () => {
    const resultArray = [[getCreateUploadAction200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/api/v1/users/:username/`, () => {
    const resultArray = [[getUpdateUser200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.patch(`${baseURL}/api/v1/users/:username/`, () => {
    const resultArray = [[getPartialUpdateUser200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/users/:username/subsonic-token/`, () => {
    const resultArray = [
      [getGetUserSubsonicToken200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/users/:username/subsonic-token/`, () => {
    const resultArray = [
      [getCreateUserSubsonicToken200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/users/:username/subsonic-token/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/users/change-email/`, () => {
    const resultArray = [
      [null, { status: 200 }],
      [null, { status: 403 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/api/v1/users/me/`, () => {
    const resultArray = [
      [getGetAuthenticatedUser200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/api/v1/users/me/`, () => {
    const resultArray = [[null, { status: 204 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/api/v1/users/settings/`, () => {
    const resultArray = [[getUpdateSettings200Response(), { status: 200 }]];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
];

export function getGetAlbums200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      release_date: faker.date.past(),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      duration: faker.number.int({ min: undefined, max: undefined }),
    })),
  };
}

export function getCreateAlbum201Response() {
  return {
    title: faker.lorem.slug(1),
    release_date: faker.date.past(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    description: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
    artist: faker.lorem.slug(1),
  };
}

export function getGetAlbum200Response() {
  return {
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      content_category: faker.helpers.arrayElement([
        "music",
        "podcast",
        "other",
      ]),
      description: {
        text: faker.lorem.slug(1),
        content_type: faker.helpers.arrayElement([
          "text/html",
          "text/markdown",
          "text/plain",
        ]),
        html: faker.lorem.slug(1),
      },
      attachment_cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.datatype.uuid(),
    },
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    is_playable: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    release_date: faker.date.past(),
    creation_date: faker.date.past(),
    is_local: faker.datatype.boolean(),
    duration: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getGetAlbumFetches200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      status: faker.helpers.arrayElement([
        "pending",
        "errored",
        "finished",
        "skipped",
      ]),
      detail: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      creation_date: faker.date.past(),
      fetch_date: faker.date.past(),
    })),
  };
}

export function getCreateAlbumFetch200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    url: faker.internet.url(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    status: faker.helpers.arrayElement([
      "pending",
      "errored",
      "finished",
      "skipped",
    ]),
    detail: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    creation_date: faker.date.past(),
    fetch_date: faker.date.past(),
  };
}

export function getGetAlbumLibraries200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      fid: faker.internet.url(),
      uuid: faker.datatype.uuid(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      name: faker.person.fullName(),
      description: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      uploads_count: faker.number.int({ min: undefined, max: undefined }),
      privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
      follow: {
        creation_date: faker.date.past(),
        uuid: faker.datatype.uuid(),
        fid: faker.internet.url(),
        approved: faker.datatype.boolean(),
        modification_date: faker.date.past(),
      },
      latest_scan: {
        total_files: faker.number.int({ min: 0, max: 2147483647 }),
        processed_files: faker.number.int({ min: 0, max: 2147483647 }),
        errored_files: faker.number.int({ min: 0, max: 2147483647 }),
        status: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
      },
    })),
  };
}

export function getGetAlbumMutations200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      fid: faker.internet.url(),
      uuid: faker.datatype.uuid(),
      type: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      applied_date: faker.date.past(),
      is_approved: faker.datatype.boolean(),
      is_applied: faker.datatype.boolean(),
      created_by: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      approved_by: faker.number.int({ min: undefined, max: undefined }),
      summary: faker.lorem.slug(1),
      payload: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      previous_state: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    })),
  };
}

export function getCreateAlbumMutation200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    type: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    applied_date: faker.date.past(),
    is_approved: faker.datatype.boolean(),
    is_applied: faker.datatype.boolean(),
    created_by: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    approved_by: faker.number.int({ min: undefined, max: undefined }),
    summary: faker.lorem.slug(1),
    payload: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    previous_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetArtists200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      albums: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        is_playable: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: faker.number.int({ min: undefined, max: undefined }),
        release_date: faker.date.past(),
        creation_date: faker.date.past(),
      })),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      channel: {
        uuid: faker.lorem.slug(1),
        actor: {
          full_username: faker.person.fullName(),
          preferred_username: faker.person.fullName(),
          domain: faker.lorem.slug(1),
        },
      },
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      content_category: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    })),
  };
}

export function getGetArtist200Response() {
  return {
    albums: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      artist: faker.number.int({ min: undefined, max: undefined }),
      release_date: faker.date.past(),
      creation_date: faker.date.past(),
    })),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    channel: {
      uuid: faker.lorem.slug(1),
      actor: {
        full_username: faker.person.fullName(),
        preferred_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
      },
    },
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    name: faker.person.fullName(),
    content_category: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    is_local: faker.datatype.boolean(),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
  };
}

export function getGetArtistFetches200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      status: faker.helpers.arrayElement([
        "pending",
        "errored",
        "finished",
        "skipped",
      ]),
      detail: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      creation_date: faker.date.past(),
      fetch_date: faker.date.past(),
    })),
  };
}

export function getCreateArtistFetch200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    url: faker.internet.url(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    status: faker.helpers.arrayElement([
      "pending",
      "errored",
      "finished",
      "skipped",
    ]),
    detail: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    creation_date: faker.date.past(),
    fetch_date: faker.date.past(),
  };
}

export function getGetArtistLibraries200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      fid: faker.internet.url(),
      uuid: faker.datatype.uuid(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      name: faker.person.fullName(),
      description: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      uploads_count: faker.number.int({ min: undefined, max: undefined }),
      privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
      follow: {
        creation_date: faker.date.past(),
        uuid: faker.datatype.uuid(),
        fid: faker.internet.url(),
        approved: faker.datatype.boolean(),
        modification_date: faker.date.past(),
      },
      latest_scan: {
        total_files: faker.number.int({ min: 0, max: 2147483647 }),
        processed_files: faker.number.int({ min: 0, max: 2147483647 }),
        errored_files: faker.number.int({ min: 0, max: 2147483647 }),
        status: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
      },
    })),
  };
}

export function getGetArtistMutations200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      fid: faker.internet.url(),
      uuid: faker.datatype.uuid(),
      type: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      applied_date: faker.date.past(),
      is_approved: faker.datatype.boolean(),
      is_applied: faker.datatype.boolean(),
      created_by: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      approved_by: faker.number.int({ min: undefined, max: undefined }),
      summary: faker.lorem.slug(1),
      payload: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      previous_state: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    })),
  };
}

export function getCreateArtistMutation200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    type: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    applied_date: faker.date.past(),
    is_approved: faker.datatype.boolean(),
    is_applied: faker.datatype.boolean(),
    created_by: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    approved_by: faker.number.int({ min: undefined, max: undefined }),
    summary: faker.lorem.slug(1),
    payload: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    previous_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getCreateAttachment201Response() {
  return {
    uuid: faker.datatype.uuid(),
    size: faker.number.int({ min: undefined, max: undefined }),
    mimetype: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    urls: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetAttachment200Response() {
  return {
    uuid: faker.datatype.uuid(),
    size: faker.number.int({ min: undefined, max: undefined }),
    mimetype: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    urls: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetAttachmentProxy200Response() {
  return {
    uuid: faker.datatype.uuid(),
    size: faker.number.int({ min: undefined, max: undefined }),
    mimetype: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    urls: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getChangePassword200Response() {
  return {
    new_password1: faker.lorem.slug(1),
    new_password2: faker.lorem.slug(1),
  };
}

export function getResetPassword200Response() {
  return {
    email: faker.internet.email(),
  };
}

export function getConfirmPasswordReset200Response() {
  return {
    new_password1: faker.lorem.slug(1),
    new_password2: faker.lorem.slug(1),
    uid: faker.lorem.slug(1),
    token: faker.lorem.slug(1),
  };
}

export function getRegister201Response() {
  return {
    username: faker.person.fullName(),
    email: faker.internet.email(),
    invitation: faker.lorem.slug(1),
  };
}

export function getChangePassword2200Response() {
  return {
    new_password1: faker.lorem.slug(1),
    new_password2: faker.lorem.slug(1),
  };
}

export function getGetAuthUser200Response() {
  return {
    pk: faker.number.int({ min: undefined, max: undefined }),
    username: faker.person.fullName(),
    email: faker.internet.email(),
    first_name: faker.person.fullName(),
    last_name: faker.person.fullName(),
  };
}

export function getUpdateAuthUser200Response() {
  return {
    pk: faker.number.int({ min: undefined, max: undefined }),
    username: faker.person.fullName(),
    email: faker.internet.email(),
    first_name: faker.person.fullName(),
    last_name: faker.person.fullName(),
  };
}

export function getPartialUpdateAuthUser200Response() {
  return {
    pk: faker.number.int({ min: undefined, max: undefined }),
    username: faker.person.fullName(),
    email: faker.internet.email(),
    first_name: faker.person.fullName(),
    last_name: faker.person.fullName(),
  };
}

export function getGetChannels200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.datatype.uuid(),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.lorem.slug(1),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.lorem.slug(1),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.slug(1)),
      },
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      creation_date: faker.date.past(),
      metadata: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      rss_url: faker.internet.url(),
      url: faker.internet.url(),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
    })),
  };
}

export function getCreateChannel201Response() {
  return {
    name: faker.person.fullName(),
    username: faker.person.fullName(),
    description: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    content_category: faker.helpers.arrayElement(["music", "podcast", "other"]),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetChannel200Response() {
  return {
    uuid: faker.datatype.uuid(),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.lorem.slug(1),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      content_category: faker.lorem.slug(1),
      description: {
        text: faker.lorem.slug(1),
        content_type: faker.helpers.arrayElement([
          "text/html",
          "text/markdown",
          "text/plain",
        ]),
        html: faker.lorem.slug(1),
      },
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.datatype.uuid(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
    },
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    creation_date: faker.date.past(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    rss_url: faker.internet.url(),
    url: faker.internet.url(),
    downloads_count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getUpdateChannel200Response() {
  return {
    name: faker.person.fullName(),
    description: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    content_category: faker.helpers.arrayElement(["music", "podcast", "other"]),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getPartialUpdateChannel200Response() {
  return {
    name: faker.person.fullName(),
    description: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    content_category: faker.helpers.arrayElement(["music", "podcast", "other"]),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetChannelRss200Response() {
  return {
    uuid: faker.datatype.uuid(),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.lorem.slug(1),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      content_category: faker.lorem.slug(1),
      description: {
        text: faker.lorem.slug(1),
        content_type: faker.helpers.arrayElement([
          "text/html",
          "text/markdown",
          "text/plain",
        ]),
        html: faker.lorem.slug(1),
      },
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.datatype.uuid(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
    },
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    creation_date: faker.date.past(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    rss_url: faker.internet.url(),
    url: faker.internet.url(),
    downloads_count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getSubscribeChannel200Response() {
  return {
    uuid: faker.datatype.uuid(),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.lorem.slug(1),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      content_category: faker.lorem.slug(1),
      description: {
        text: faker.lorem.slug(1),
        content_type: faker.helpers.arrayElement([
          "text/html",
          "text/markdown",
          "text/plain",
        ]),
        html: faker.lorem.slug(1),
      },
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.datatype.uuid(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
    },
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    creation_date: faker.date.past(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    rss_url: faker.internet.url(),
    url: faker.internet.url(),
    downloads_count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getGetChannelMetadataChoices200Response() {
  return {
    uuid: faker.datatype.uuid(),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.lorem.slug(1),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      content_category: faker.lorem.slug(1),
      description: {
        text: faker.lorem.slug(1),
        content_type: faker.helpers.arrayElement([
          "text/html",
          "text/markdown",
          "text/plain",
        ]),
        html: faker.lorem.slug(1),
      },
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.datatype.uuid(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
    },
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    creation_date: faker.date.past(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    rss_url: faker.internet.url(),
    url: faker.internet.url(),
    downloads_count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getSubscribeChannelRss200Response() {
  return {
    uuid: faker.datatype.uuid(),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.lorem.slug(1),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      content_category: faker.lorem.slug(1),
      description: {
        text: faker.lorem.slug(1),
        content_type: faker.helpers.arrayElement([
          "text/html",
          "text/markdown",
          "text/plain",
        ]),
        html: faker.lorem.slug(1),
      },
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.datatype.uuid(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
    },
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    creation_date: faker.date.past(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    rss_url: faker.internet.url(),
    url: faker.internet.url(),
    downloads_count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getGetFavoriteTracks200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      user: {
        id: faker.number.int({ min: undefined, max: undefined }),
        username: faker.person.fullName(),
        name: faker.person.fullName(),
        date_joined: faker.date.past(),
        avatar: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
      },
      track: {
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        album: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          title: faker.lorem.slug(1),
          artist: {
            id: faker.number.int({ min: undefined, max: undefined }),
            fid: faker.internet.url(),
            mbid: faker.datatype.uuid(),
            name: faker.person.fullName(),
            creation_date: faker.date.past(),
            modification_date: faker.date.past(),
            is_local: faker.datatype.boolean(),
            content_category: faker.helpers.arrayElement([
              "music",
              "podcast",
              "other",
            ]),
            description: {
              text: faker.lorem.slug(1),
              content_type: faker.helpers.arrayElement([
                "text/html",
                "text/markdown",
                "text/plain",
              ]),
              html: faker.lorem.slug(1),
            },
            attachment_cover: {
              uuid: faker.datatype.uuid(),
              size: faker.number.int({ min: undefined, max: undefined }),
              mimetype: faker.lorem.slug(1),
              creation_date: faker.date.past(),
              urls: [...new Array(5).keys()]
                .map((_) => ({ [faker.lorem.word()]: null }))
                .reduce((acc, next) => Object.assign(acc, next), {}),
            },
            channel: faker.datatype.uuid(),
          },
          release_date: faker.date.past(),
          cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          creation_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          tracks_count: faker.number.int({ min: undefined, max: undefined }),
        },
        uploads: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.datatype.uuid(),
          listen_url: faker.internet.url(),
          size: faker.number.int({ min: undefined, max: undefined }),
          duration: faker.number.int({ min: undefined, max: undefined }),
          bitrate: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          extension: faker.lorem.slug(1),
          is_local: faker.datatype.boolean(),
        })),
        listen_url: faker.internet.url(),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.slug(1)),
        attributed_to: {
          fid: faker.internet.url(),
          url: faker.internet.url(),
          creation_date: faker.date.past(),
          summary: faker.lorem.slug(1),
          preferred_username: faker.person.fullName(),
          name: faker.person.fullName(),
          last_fetch_date: faker.date.past(),
          domain: faker.lorem.slug(1),
          type: faker.helpers.arrayElement([
            "Person",
            "Tombstone",
            "Application",
            "Group",
            "Organization",
            "Service",
          ]),
          manually_approves_followers: faker.datatype.boolean(),
          full_username: faker.person.fullName(),
          is_local: faker.datatype.boolean(),
        },
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        position: faker.number.int({ min: undefined, max: undefined }),
        disc_number: faker.number.int({ min: undefined, max: undefined }),
        downloads_count: faker.number.int({ min: undefined, max: undefined }),
        copyright: faker.lorem.slug(1),
        license: faker.lorem.slug(1),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        is_playable: faker.datatype.boolean(),
      },
      creation_date: faker.date.past(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
    })),
  };
}

export function getFavoriteTrack201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    track: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
  };
}

export function getGetAllFavoriteTracks200Response() {
  return {
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      track: faker.number.int({ min: undefined, max: undefined }),
    })),
    count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getUnfavoriteTrack2200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    track: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
  };
}

export function getGetFederationActor200Response() {
  return {
    fid: faker.internet.url(),
    url: faker.internet.url(),
    domain: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    last_fetch_date: faker.date.past(),
    name: faker.person.fullName(),
    preferred_username: faker.person.fullName(),
    full_username: faker.person.fullName(),
    type: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    is_channel: faker.datatype.boolean(),
    manually_approves_followers: faker.datatype.boolean(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    summary: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
    icon: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
  };
}

export function getGetFederationActorLibrary200Response() {
  return {
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getGetFederationDomains200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
    })),
  };
}

export function getGetFederationDomain200Response() {
  return {
    name: faker.person.fullName(),
  };
}

export function getCreateFederationFetch201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    url: faker.internet.url(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    status: faker.helpers.arrayElement([
      "pending",
      "errored",
      "finished",
      "skipped",
    ]),
    detail: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    creation_date: faker.date.past(),
    fetch_date: faker.date.past(),
  };
}

export function getGetFederationFetch200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    url: faker.internet.url(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    status: faker.helpers.arrayElement([
      "pending",
      "errored",
      "finished",
      "skipped",
    ]),
    detail: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    creation_date: faker.date.past(),
    fetch_date: faker.date.past(),
  };
}

export function getGetFederationLibraryFollows200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      creation_date: faker.date.past(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      uuid: faker.datatype.uuid(),
      target: faker.lorem.slug(1),
      approved: faker.datatype.boolean(),
    })),
  };
}

export function getCreateFederationLibraryFollow201Response() {
  return {
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    uuid: faker.datatype.uuid(),
    target: faker.lorem.slug(1),
    approved: faker.datatype.boolean(),
  };
}

export function getGetFederationLibraryFollow200Response() {
  return {
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    uuid: faker.datatype.uuid(),
    target: faker.lorem.slug(1),
    approved: faker.datatype.boolean(),
  };
}

export function getRejectFederationLibraryFollow200Response() {
  return {
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    uuid: faker.datatype.uuid(),
    target: faker.lorem.slug(1),
    approved: faker.datatype.boolean(),
  };
}

export function getGetAllFederationLibraryFollows200Response() {
  return {
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    uuid: faker.datatype.uuid(),
    target: faker.lorem.slug(1),
    approved: faker.datatype.boolean(),
  };
}

export function getGetFederationInboxes200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      type: faker.helpers.arrayElement(["to", "cc"]),
      activity: {
        uuid: faker.datatype.uuid(),
        fid: faker.internet.url(),
        actor: {
          fid: faker.internet.url(),
          url: faker.internet.url(),
          creation_date: faker.date.past(),
          summary: faker.lorem.slug(1),
          preferred_username: faker.person.fullName(),
          name: faker.person.fullName(),
          last_fetch_date: faker.date.past(),
          domain: faker.lorem.slug(1),
          type: faker.helpers.arrayElement([
            "Person",
            "Tombstone",
            "Application",
            "Group",
            "Organization",
            "Service",
          ]),
          manually_approves_followers: faker.datatype.boolean(),
          full_username: faker.person.fullName(),
          is_local: faker.datatype.boolean(),
        },
        payload: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        object: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        target: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        related_object: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        creation_date: faker.date.past(),
        type: faker.lorem.slug(1),
      },
      is_read: faker.datatype.boolean(),
    })),
  };
}

export function getGetFederationInbox200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    type: faker.helpers.arrayElement(["to", "cc"]),
    activity: {
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      payload: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      object: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      related_object: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      creation_date: faker.date.past(),
      type: faker.lorem.slug(1),
    },
    is_read: faker.datatype.boolean(),
  };
}

export function getUpdateFederationInbox200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    type: faker.helpers.arrayElement(["to", "cc"]),
    activity: {
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      payload: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      object: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      related_object: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      creation_date: faker.date.past(),
      type: faker.lorem.slug(1),
    },
    is_read: faker.datatype.boolean(),
  };
}

export function getPartialUpdateFederationInbox200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    type: faker.helpers.arrayElement(["to", "cc"]),
    activity: {
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      payload: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      object: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      related_object: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      creation_date: faker.date.past(),
      type: faker.lorem.slug(1),
    },
    is_read: faker.datatype.boolean(),
  };
}

export function getCreateFederationInboxAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    type: faker.helpers.arrayElement(["to", "cc"]),
    activity: {
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      payload: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      object: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      related_object: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      creation_date: faker.date.past(),
      type: faker.lorem.slug(1),
    },
    is_read: faker.datatype.boolean(),
  };
}

export function getGetFederationLibrary200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    follow: {
      creation_date: faker.date.past(),
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      approved: faker.datatype.boolean(),
      modification_date: faker.date.past(),
    },
    latest_scan: {
      total_files: faker.number.int({ min: 0, max: 2147483647 }),
      processed_files: faker.number.int({ min: 0, max: 2147483647 }),
      errored_files: faker.number.int({ min: 0, max: 2147483647 }),
      status: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
    },
  };
}

export function getCreateFederationLibraryScan200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    follow: {
      creation_date: faker.date.past(),
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      approved: faker.datatype.boolean(),
      modification_date: faker.date.past(),
    },
    latest_scan: {
      total_files: faker.number.int({ min: 0, max: 2147483647 }),
      processed_files: faker.number.int({ min: 0, max: 2147483647 }),
      errored_files: faker.number.int({ min: 0, max: 2147483647 }),
      status: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
    },
  };
}

export function getCreateFederationLibraryFetch200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    follow: {
      creation_date: faker.date.past(),
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      approved: faker.datatype.boolean(),
      modification_date: faker.date.past(),
    },
    latest_scan: {
      total_files: faker.number.int({ min: 0, max: 2147483647 }),
      processed_files: faker.number.int({ min: 0, max: 2147483647 }),
      errored_files: faker.number.int({ min: 0, max: 2147483647 }),
      status: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
    },
  };
}

export function getGetHistoryListenings200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      user: {
        id: faker.number.int({ min: undefined, max: undefined }),
        username: faker.person.fullName(),
        name: faker.person.fullName(),
        date_joined: faker.date.past(),
        avatar: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
      },
      track: {
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        album: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          title: faker.lorem.slug(1),
          artist: {
            id: faker.number.int({ min: undefined, max: undefined }),
            fid: faker.internet.url(),
            mbid: faker.datatype.uuid(),
            name: faker.person.fullName(),
            creation_date: faker.date.past(),
            modification_date: faker.date.past(),
            is_local: faker.datatype.boolean(),
            content_category: faker.helpers.arrayElement([
              "music",
              "podcast",
              "other",
            ]),
            description: {
              text: faker.lorem.slug(1),
              content_type: faker.helpers.arrayElement([
                "text/html",
                "text/markdown",
                "text/plain",
              ]),
              html: faker.lorem.slug(1),
            },
            attachment_cover: {
              uuid: faker.datatype.uuid(),
              size: faker.number.int({ min: undefined, max: undefined }),
              mimetype: faker.lorem.slug(1),
              creation_date: faker.date.past(),
              urls: [...new Array(5).keys()]
                .map((_) => ({ [faker.lorem.word()]: null }))
                .reduce((acc, next) => Object.assign(acc, next), {}),
            },
            channel: faker.datatype.uuid(),
          },
          release_date: faker.date.past(),
          cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          creation_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          tracks_count: faker.number.int({ min: undefined, max: undefined }),
        },
        uploads: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.datatype.uuid(),
          listen_url: faker.internet.url(),
          size: faker.number.int({ min: undefined, max: undefined }),
          duration: faker.number.int({ min: undefined, max: undefined }),
          bitrate: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          extension: faker.lorem.slug(1),
          is_local: faker.datatype.boolean(),
        })),
        listen_url: faker.internet.url(),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.slug(1)),
        attributed_to: {
          fid: faker.internet.url(),
          url: faker.internet.url(),
          creation_date: faker.date.past(),
          summary: faker.lorem.slug(1),
          preferred_username: faker.person.fullName(),
          name: faker.person.fullName(),
          last_fetch_date: faker.date.past(),
          domain: faker.lorem.slug(1),
          type: faker.helpers.arrayElement([
            "Person",
            "Tombstone",
            "Application",
            "Group",
            "Organization",
            "Service",
          ]),
          manually_approves_followers: faker.datatype.boolean(),
          full_username: faker.person.fullName(),
          is_local: faker.datatype.boolean(),
        },
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        position: faker.number.int({ min: undefined, max: undefined }),
        disc_number: faker.number.int({ min: undefined, max: undefined }),
        downloads_count: faker.number.int({ min: undefined, max: undefined }),
        copyright: faker.lorem.slug(1),
        license: faker.lorem.slug(1),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        is_playable: faker.datatype.boolean(),
      },
      creation_date: faker.date.past(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
    })),
  };
}

export function getCreateHistoryListening201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    user: faker.number.int({ min: undefined, max: undefined }),
    track: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
  };
}

export function getGetHistoryListening200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    track: {
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
      },
      uploads: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.datatype.uuid(),
        listen_url: faker.internet.url(),
        size: faker.number.int({ min: undefined, max: undefined }),
        duration: faker.number.int({ min: undefined, max: undefined }),
        bitrate: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        extension: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      })),
      listen_url: faker.internet.url(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      position: faker.number.int({ min: undefined, max: undefined }),
      disc_number: faker.number.int({ min: undefined, max: undefined }),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
    },
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getGetInstanceAdminSettings200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    section: faker.lorem.slug(1),
    name: faker.person.fullName(),
    identifier: faker.lorem.slug(1),
    default: faker.lorem.slug(1),
    value: faker.lorem.slug(1),
    verbose_name: faker.person.fullName(),
    help_text: faker.lorem.slug(1),
    additional_data: faker.lorem.slug(1),
    field: faker.lorem.slug(1),
  }));
}

export function getGetInstanceAdminSetting200Response() {
  return {
    section: faker.lorem.slug(1),
    name: faker.person.fullName(),
    identifier: faker.lorem.slug(1),
    default: faker.lorem.slug(1),
    value: faker.lorem.slug(1),
    verbose_name: faker.person.fullName(),
    help_text: faker.lorem.slug(1),
    additional_data: faker.lorem.slug(1),
    field: faker.lorem.slug(1),
  };
}

export function getUpdateInstanceAdminSetting200Response() {
  return {
    section: faker.lorem.slug(1),
    name: faker.person.fullName(),
    identifier: faker.lorem.slug(1),
    default: faker.lorem.slug(1),
    value: faker.lorem.slug(1),
    verbose_name: faker.person.fullName(),
    help_text: faker.lorem.slug(1),
    additional_data: faker.lorem.slug(1),
    field: faker.lorem.slug(1),
  };
}

export function getPartialUpdateInstanceAdminSetting200Response() {
  return {
    section: faker.lorem.slug(1),
    name: faker.person.fullName(),
    identifier: faker.lorem.slug(1),
    default: faker.lorem.slug(1),
    value: faker.lorem.slug(1),
    verbose_name: faker.person.fullName(),
    help_text: faker.lorem.slug(1),
    additional_data: faker.lorem.slug(1),
    field: faker.lorem.slug(1),
  };
}

export function getCreateInstanceAdminSettingBulk200Response() {
  return {
    section: faker.lorem.slug(1),
    name: faker.person.fullName(),
    identifier: faker.lorem.slug(1),
    default: faker.lorem.slug(1),
    value: faker.lorem.slug(1),
    verbose_name: faker.person.fullName(),
    help_text: faker.lorem.slug(1),
    additional_data: faker.lorem.slug(1),
    field: faker.lorem.slug(1),
  };
}

export function getGetNodeInfo20200Response() {
  return {
    version: faker.lorem.slug(1),
    software: {
      name: faker.person.fullName(),
      version: faker.lorem.slug(1),
    },
    protocols: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    services: {
      inbound: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      outbound: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
    },
    openRegistrations: faker.datatype.boolean(),
    usage: {
      users: {
        total: faker.number.int({ min: undefined, max: undefined }),
        activeHalfyear: faker.number.int({ min: undefined, max: undefined }),
        activeMonth: faker.number.int({ min: undefined, max: undefined }),
      },
      localPosts: faker.number.int({ min: undefined, max: undefined }),
      localComments: faker.number.int({ min: undefined, max: undefined }),
    },
    metadata: {
      actorId: faker.lorem.slug(1),
      private: faker.datatype.boolean(),
      shortDescription: faker.lorem.slug(1),
      longDescription: faker.lorem.slug(1),
      contactEmail: faker.internet.email(),
      nodeName: faker.person.fullName(),
      banner: faker.lorem.slug(1),
      defaultUploadQuota: faker.number.int({ min: undefined, max: undefined }),
      supportedUploadExtensions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      allowList: {
        enabled: faker.datatype.boolean(),
        domains: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.slug(1)),
      },
      funkwhaleSupportMessageEnabled: faker.datatype.boolean(),
      instanceSupportMessage: faker.lorem.slug(1),
      usage: {
        favorites: {
          tracks: {
            total: faker.number.int({ min: undefined, max: undefined }),
          },
        },
        listenings: {
          total: faker.number.int({ min: undefined, max: undefined }),
        },
        downloads: {
          total: faker.number.int({ min: undefined, max: undefined }),
        },
      },
      library: {
        federationEnabled: faker.datatype.boolean(),
        anonymousCanListen: faker.datatype.boolean(),
        tracks: {
          total: faker.number.int({ min: undefined, max: undefined }),
        },
        artists: {
          total: faker.number.int({ min: undefined, max: undefined }),
        },
        albums: {
          total: faker.number.int({ min: undefined, max: undefined }),
        },
        music: {
          hours: faker.number.int({ min: undefined, max: undefined }),
        },
      },
      reportTypes: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        type: faker.lorem.slug(1),
        label: faker.lorem.slug(1),
        anonymous: faker.datatype.boolean(),
      })),
      endpoints: {
        knownNodes: faker.internet.url(),
        channels: faker.internet.url(),
        libraries: faker.internet.url(),
      },
      rules: faker.lorem.slug(1),
      terms: faker.lorem.slug(1),
    },
  };
}

export function getGetInstanceSettings200Response() {
  return {
    section: faker.lorem.slug(1),
    name: faker.person.fullName(),
    identifier: faker.lorem.slug(1),
    default: faker.lorem.slug(1),
    value: faker.lorem.slug(1),
    verbose_name: faker.person.fullName(),
    help_text: faker.lorem.slug(1),
    additional_data: faker.lorem.slug(1),
    field: faker.lorem.slug(1),
  };
}

export function getGetSpaManifest200Response() {
  return null;
}

export function getGetLibraries200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      name: faker.person.fullName(),
      description: faker.lorem.slug(1),
      privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
      uploads_count: faker.number.int({ min: undefined, max: undefined }),
      size: faker.number.int({ min: undefined, max: undefined }),
      creation_date: faker.date.past(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
    })),
  };
}

export function getCreateLibrary201Response() {
  return {
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getGetLibrary200Response() {
  return {
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getUpdateLibrary200Response() {
  return {
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getPartialUpdateLibrary200Response() {
  return {
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getGetLibraryFollows200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      creation_date: faker.date.past(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      uuid: faker.datatype.uuid(),
      target: faker.lorem.slug(1),
      approved: faker.datatype.boolean(),
    })),
  };
}

export function getGetLicenses200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.lorem.slug(1),
      url: faker.internet.url(),
      code: faker.lorem.slug(1),
      name: faker.person.fullName(),
      redistribute: faker.datatype.boolean(),
      derivative: faker.datatype.boolean(),
      commercial: faker.datatype.boolean(),
      attribution: faker.datatype.boolean(),
      copyleft: faker.datatype.boolean(),
    })),
  };
}

export function getGetLicense200Response() {
  return {
    id: faker.lorem.slug(1),
    url: faker.internet.url(),
    code: faker.lorem.slug(1),
    name: faker.person.fullName(),
    redistribute: faker.datatype.boolean(),
    derivative: faker.datatype.boolean(),
    commercial: faker.datatype.boolean(),
    attribution: faker.datatype.boolean(),
    copyleft: faker.datatype.boolean(),
  };
}

export function getGetListen200Response() {
  return null;
}

export function getAdminGetAccounts200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
      uploads_count: faker.number.int({ min: undefined, max: undefined }),
      user: {
        id: faker.number.int({ min: undefined, max: undefined }),
        username: faker.person.fullName(),
        actor: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
        email: faker.internet.email(),
        name: faker.person.fullName(),
        is_active: faker.datatype.boolean(),
        is_staff: faker.datatype.boolean(),
        is_superuser: faker.datatype.boolean(),
        date_joined: faker.date.past(),
        last_activity: faker.date.past(),
        privacy_level: faker.helpers.arrayElement([
          "me",
          "followers",
          "instance",
          "everyone",
        ]),
        upload_quota: faker.number.int({ min: undefined, max: undefined }),
        full_username: faker.person.fullName(),
      },
      instance_policy: faker.number.int({ min: undefined, max: undefined }),
    })),
  };
}

export function getAdminGetAccount200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    url: faker.internet.url(),
    fid: faker.internet.url(),
    preferred_username: faker.person.fullName(),
    full_username: faker.person.fullName(),
    domain: faker.lorem.slug(1),
    name: faker.person.fullName(),
    summary: faker.lorem.slug(1),
    type: faker.helpers.arrayElement([
      "Person",
      "Tombstone",
      "Application",
      "Group",
      "Organization",
      "Service",
    ]),
    creation_date: faker.date.past(),
    last_fetch_date: faker.date.past(),
    inbox_url: faker.internet.url(),
    outbox_url: faker.internet.url(),
    shared_inbox_url: faker.internet.url(),
    manually_approves_followers: faker.datatype.boolean(),
    is_local: faker.datatype.boolean(),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      actor: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: undefined, max: undefined }),
      full_username: faker.person.fullName(),
    },
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getAdminGetAccountStats200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    url: faker.internet.url(),
    fid: faker.internet.url(),
    preferred_username: faker.person.fullName(),
    full_username: faker.person.fullName(),
    domain: faker.lorem.slug(1),
    name: faker.person.fullName(),
    summary: faker.lorem.slug(1),
    type: faker.helpers.arrayElement([
      "Person",
      "Tombstone",
      "Application",
      "Group",
      "Organization",
      "Service",
    ]),
    creation_date: faker.date.past(),
    last_fetch_date: faker.date.past(),
    inbox_url: faker.internet.url(),
    outbox_url: faker.internet.url(),
    shared_inbox_url: faker.internet.url(),
    manually_approves_followers: faker.datatype.boolean(),
    is_local: faker.datatype.boolean(),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      actor: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: undefined, max: undefined }),
      full_username: faker.person.fullName(),
    },
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getAdminCreateAccountAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    url: faker.internet.url(),
    fid: faker.internet.url(),
    preferred_username: faker.person.fullName(),
    full_username: faker.person.fullName(),
    domain: faker.lorem.slug(1),
    name: faker.person.fullName(),
    summary: faker.lorem.slug(1),
    type: faker.helpers.arrayElement([
      "Person",
      "Tombstone",
      "Application",
      "Group",
      "Organization",
      "Service",
    ]),
    creation_date: faker.date.past(),
    last_fetch_date: faker.date.past(),
    inbox_url: faker.internet.url(),
    outbox_url: faker.internet.url(),
    shared_inbox_url: faker.internet.url(),
    manually_approves_followers: faker.datatype.boolean(),
    is_local: faker.datatype.boolean(),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      actor: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: undefined, max: undefined }),
      full_username: faker.person.fullName(),
    },
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getAdminGetChannels200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      creation_date: faker.date.past(),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
        albums_count: faker.number.int({ min: undefined, max: undefined }),
        attributed_to: {
          id: faker.number.int({ min: undefined, max: undefined }),
          url: faker.internet.url(),
          fid: faker.internet.url(),
          preferred_username: faker.person.fullName(),
          full_username: faker.person.fullName(),
          domain: faker.lorem.slug(1),
          name: faker.person.fullName(),
          summary: faker.lorem.slug(1),
          type: faker.helpers.arrayElement([
            "Person",
            "Tombstone",
            "Application",
            "Group",
            "Organization",
            "Service",
          ]),
          creation_date: faker.date.past(),
          last_fetch_date: faker.date.past(),
          inbox_url: faker.internet.url(),
          outbox_url: faker.internet.url(),
          shared_inbox_url: faker.internet.url(),
          manually_approves_followers: faker.datatype.boolean(),
          is_local: faker.datatype.boolean(),
        },
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.slug(1)),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.lorem.slug(1),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
      },
      attributed_to: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      actor: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      rss_url: faker.internet.url(),
      metadata: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    })),
  };
}

export function getAdminGetChannel200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    creation_date: faker.date.past(),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      albums_count: faker.number.int({ min: undefined, max: undefined }),
      attributed_to: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.lorem.slug(1),
      content_category: faker.helpers.arrayElement([
        "music",
        "podcast",
        "other",
      ]),
    },
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    actor: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    rss_url: faker.internet.url(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getAdminGetChannelStats200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    creation_date: faker.date.past(),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      albums_count: faker.number.int({ min: undefined, max: undefined }),
      attributed_to: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.lorem.slug(1),
      content_category: faker.helpers.arrayElement([
        "music",
        "podcast",
        "other",
      ]),
    },
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    actor: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    rss_url: faker.internet.url(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getAdminGetFederationDomains200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.internet.url(),
      creation_date: faker.date.past(),
      actors_count: faker.number.int({ min: undefined, max: undefined }),
      outbox_activities_count: faker.number.int({
        min: undefined,
        max: undefined,
      }),
      nodeinfo: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      nodeinfo_fetch_date: faker.date.past(),
      instance_policy: faker.number.int({ min: undefined, max: undefined }),
      allowed: faker.datatype.boolean(),
    })),
  };
}

export function getAdminCreateFederationDomain201Response() {
  return {
    name: faker.internet.url(),
    creation_date: faker.date.past(),
    actors_count: faker.number.int({ min: undefined, max: undefined }),
    outbox_activities_count: faker.number.int({
      min: undefined,
      max: undefined,
    }),
    nodeinfo: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    nodeinfo_fetch_date: faker.date.past(),
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
    allowed: faker.datatype.boolean(),
  };
}

export function getAdminGetFederationDomain200Response() {
  return {
    name: faker.internet.url(),
    creation_date: faker.date.past(),
    actors_count: faker.number.int({ min: undefined, max: undefined }),
    outbox_activities_count: faker.number.int({
      min: undefined,
      max: undefined,
    }),
    nodeinfo: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    nodeinfo_fetch_date: faker.date.past(),
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
    allowed: faker.datatype.boolean(),
  };
}

export function getAdminUpdateFederationDomain200Response() {
  return {
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    actors_count: faker.number.int({ min: undefined, max: undefined }),
    outbox_activities_count: faker.number.int({
      min: undefined,
      max: undefined,
    }),
    nodeinfo: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    nodeinfo_fetch_date: faker.date.past(),
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
    allowed: faker.datatype.boolean(),
  };
}

export function getAdminPartialUpdateFederationDomain200Response() {
  return {
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    actors_count: faker.number.int({ min: undefined, max: undefined }),
    outbox_activities_count: faker.number.int({
      min: undefined,
      max: undefined,
    }),
    nodeinfo: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    nodeinfo_fetch_date: faker.date.past(),
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
    allowed: faker.datatype.boolean(),
  };
}

export function getAdminGetFederationDomainNodeinfo200Response() {
  return {
    name: faker.internet.url(),
    creation_date: faker.date.past(),
    actors_count: faker.number.int({ min: undefined, max: undefined }),
    outbox_activities_count: faker.number.int({
      min: undefined,
      max: undefined,
    }),
    nodeinfo: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    nodeinfo_fetch_date: faker.date.past(),
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
    allowed: faker.datatype.boolean(),
  };
}

export function getAdminGetFederationDomainStats200Response() {
  return {
    name: faker.internet.url(),
    creation_date: faker.date.past(),
    actors_count: faker.number.int({ min: undefined, max: undefined }),
    outbox_activities_count: faker.number.int({
      min: undefined,
      max: undefined,
    }),
    nodeinfo: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    nodeinfo_fetch_date: faker.date.past(),
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
    allowed: faker.datatype.boolean(),
  };
}

export function getAdminCreateFederationDomainAction200Response() {
  return {
    name: faker.internet.url(),
    creation_date: faker.date.past(),
    actors_count: faker.number.int({ min: undefined, max: undefined }),
    outbox_activities_count: faker.number.int({
      min: undefined,
      max: undefined,
    }),
    nodeinfo: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    nodeinfo_fetch_date: faker.date.past(),
    instance_policy: faker.number.int({ min: undefined, max: undefined }),
    allowed: faker.datatype.boolean(),
  };
}

export function getAdminGetAlbums200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      release_date: faker.date.past(),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      },
      attributed_to: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
    })),
  };
}

export function getAdminGetAlbum200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    release_date: faker.date.past(),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
    },
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
  };
}

export function getAdminGetLibraryAlbumStats200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    release_date: faker.date.past(),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
    },
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
  };
}

export function getAdminCreateAlbumAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    release_date: faker.date.past(),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
    },
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
  };
}

export function getAdminGetArtists200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      albums_count: faker.number.int({ min: undefined, max: undefined }),
      attributed_to: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.lorem.slug(1),
      content_category: faker.helpers.arrayElement([
        "music",
        "podcast",
        "other",
      ]),
    })),
  };
}

export function getAdminGetArtist200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    albums_count: faker.number.int({ min: undefined, max: undefined }),
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    channel: faker.lorem.slug(1),
    content_category: faker.helpers.arrayElement(["music", "podcast", "other"]),
  };
}

export function getAdminGetLibraryArtistStats200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    albums_count: faker.number.int({ min: undefined, max: undefined }),
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    channel: faker.lorem.slug(1),
    content_category: faker.helpers.arrayElement(["music", "podcast", "other"]),
  };
}

export function getAdminCreateArtistAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    albums_count: faker.number.int({ min: undefined, max: undefined }),
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    channel: faker.lorem.slug(1),
    content_category: faker.helpers.arrayElement(["music", "podcast", "other"]),
  };
}

export function getAdminGetLibraries200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      url: faker.internet.url(),
      name: faker.person.fullName(),
      description: faker.lorem.slug(1),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      creation_date: faker.date.past(),
      privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
      uploads_count: faker.number.int({ min: undefined, max: undefined }),
      followers_count: faker.number.int({ min: undefined, max: undefined }),
      followers_url: faker.internet.url(),
      actor: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
    })),
  };
}

export function getAdminGetLibrary200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    url: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    followers_count: faker.number.int({ min: undefined, max: undefined }),
    followers_url: faker.internet.url(),
    actor: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getAdminUpdateLibrary200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    url: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    followers_count: faker.number.int({ min: undefined, max: undefined }),
    followers_url: faker.internet.url(),
    actor: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getAdminPartialUpdateLibrary200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    url: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    followers_count: faker.number.int({ min: undefined, max: undefined }),
    followers_url: faker.internet.url(),
    actor: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getAdminGetLibraryStats200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    url: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    followers_count: faker.number.int({ min: undefined, max: undefined }),
    followers_url: faker.internet.url(),
    actor: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getAdminCreateLibraryAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    url: faker.internet.url(),
    name: faker.person.fullName(),
    description: faker.lorem.slug(1),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    followers_count: faker.number.int({ min: undefined, max: undefined }),
    followers_url: faker.internet.url(),
    actor: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getAdminGetTracks200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      position: faker.number.int({ min: 0, max: 2147483647 }),
      disc_number: faker.number.int({ min: 0, max: 2147483647 }),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          domain: faker.lorem.slug(1),
          is_local: faker.datatype.boolean(),
        },
      },
      attributed_to: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      uploads_count: faker.number.int({ min: undefined, max: undefined }),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    })),
  };
}

export function getAdminGetTrack200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    position: faker.number.int({ min: 0, max: 2147483647 }),
    disc_number: faker.number.int({ min: 0, max: 2147483647 }),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    copyright: faker.lorem.slug(1),
    license: faker.lorem.slug(1),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
    },
    album: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      release_date: faker.date.past(),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      },
    },
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
  };
}

export function getAdminGetTrackStats200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    position: faker.number.int({ min: 0, max: 2147483647 }),
    disc_number: faker.number.int({ min: 0, max: 2147483647 }),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    copyright: faker.lorem.slug(1),
    license: faker.lorem.slug(1),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
    },
    album: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      release_date: faker.date.past(),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      },
    },
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
  };
}

export function getAdminCreateTrackAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    position: faker.number.int({ min: 0, max: 2147483647 }),
    disc_number: faker.number.int({ min: 0, max: 2147483647 }),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    copyright: faker.lorem.slug(1),
    license: faker.lorem.slug(1),
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
    },
    album: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      release_date: faker.date.past(),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      },
    },
    attributed_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    uploads_count: faker.number.int({ min: undefined, max: undefined }),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
  };
}

export function getAdminGetUploads200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      audio_file: faker.internet.url(),
      listen_url: faker.internet.url(),
      source: faker.lorem.slug(1),
      filename: faker.person.fullName(),
      mimetype: faker.lorem.slug(1),
      duration: faker.number.int({ min: -2147483648, max: 2147483647 }),
      bitrate: faker.number.int({ min: -2147483648, max: 2147483647 }),
      size: faker.number.int({ min: -2147483648, max: 2147483647 }),
      creation_date: faker.date.past(),
      accessed_date: faker.date.past(),
      modification_date: faker.date.past(),
      metadata: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      import_date: faker.date.past(),
      import_details: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      import_status: faker.helpers.arrayElement([
        "draft",
        "pending",
        "finished",
        "errored",
        "skipped",
      ]),
      import_metadata: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      import_reference: faker.lorem.slug(1),
      track: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        position: faker.number.int({ min: 0, max: 2147483647 }),
        disc_number: faker.number.int({ min: 0, max: 2147483647 }),
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
        copyright: faker.lorem.slug(1),
        license: faker.lorem.slug(1),
      },
      library: {
        id: faker.number.int({ min: undefined, max: undefined }),
        uuid: faker.datatype.uuid(),
        fid: faker.internet.url(),
        url: faker.internet.url(),
        name: faker.person.fullName(),
        description: faker.lorem.slug(1),
        domain: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
        creation_date: faker.date.past(),
        privacy_level: faker.helpers.arrayElement([
          "me",
          "instance",
          "everyone",
        ]),
        followers_url: faker.internet.url(),
        actor: {
          id: faker.number.int({ min: undefined, max: undefined }),
          url: faker.internet.url(),
          fid: faker.internet.url(),
          preferred_username: faker.person.fullName(),
          full_username: faker.person.fullName(),
          domain: faker.lorem.slug(1),
          name: faker.person.fullName(),
          summary: faker.lorem.slug(1),
          type: faker.helpers.arrayElement([
            "Person",
            "Tombstone",
            "Application",
            "Group",
            "Organization",
            "Service",
          ]),
          creation_date: faker.date.past(),
          last_fetch_date: faker.date.past(),
          inbox_url: faker.internet.url(),
          outbox_url: faker.internet.url(),
          shared_inbox_url: faker.internet.url(),
          manually_approves_followers: faker.datatype.boolean(),
          is_local: faker.datatype.boolean(),
        },
      },
    })),
  };
}

export function getAdminGetUpload200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    audio_file: faker.internet.url(),
    listen_url: faker.internet.url(),
    source: faker.lorem.slug(1),
    filename: faker.person.fullName(),
    mimetype: faker.lorem.slug(1),
    duration: faker.number.int({ min: -2147483648, max: 2147483647 }),
    bitrate: faker.number.int({ min: -2147483648, max: 2147483647 }),
    size: faker.number.int({ min: -2147483648, max: 2147483647 }),
    creation_date: faker.date.past(),
    accessed_date: faker.date.past(),
    modification_date: faker.date.past(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_date: faker.date.past(),
    import_details: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_status: faker.helpers.arrayElement([
      "draft",
      "pending",
      "finished",
      "errored",
      "skipped",
    ]),
    import_metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_reference: faker.lorem.slug(1),
    track: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      position: faker.number.int({ min: 0, max: 2147483647 }),
      disc_number: faker.number.int({ min: 0, max: 2147483647 }),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
    },
    library: {
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      url: faker.internet.url(),
      name: faker.person.fullName(),
      description: faker.lorem.slug(1),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      creation_date: faker.date.past(),
      privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
      followers_url: faker.internet.url(),
      actor: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
    },
  };
}

export function getAdminCreateUploadAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    domain: faker.lorem.slug(1),
    is_local: faker.datatype.boolean(),
    audio_file: faker.internet.url(),
    listen_url: faker.internet.url(),
    source: faker.lorem.slug(1),
    filename: faker.person.fullName(),
    mimetype: faker.lorem.slug(1),
    duration: faker.number.int({ min: -2147483648, max: 2147483647 }),
    bitrate: faker.number.int({ min: -2147483648, max: 2147483647 }),
    size: faker.number.int({ min: -2147483648, max: 2147483647 }),
    creation_date: faker.date.past(),
    accessed_date: faker.date.past(),
    modification_date: faker.date.past(),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_date: faker.date.past(),
    import_details: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_status: faker.helpers.arrayElement([
      "draft",
      "pending",
      "finished",
      "errored",
      "skipped",
    ]),
    import_metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_reference: faker.lorem.slug(1),
    track: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      position: faker.number.int({ min: 0, max: 2147483647 }),
      disc_number: faker.number.int({ min: 0, max: 2147483647 }),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
    },
    library: {
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      url: faker.internet.url(),
      name: faker.person.fullName(),
      description: faker.lorem.slug(1),
      domain: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
      creation_date: faker.date.past(),
      privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
      followers_url: faker.internet.url(),
      actor: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
    },
  };
}

export function getModerationGetInstancePolicies200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      target: {
        type: faker.helpers.arrayElement(["domain", "actor"]),
        id: faker.lorem.slug(1),
      },
      creation_date: faker.date.past(),
      actor: faker.internet.email(),
      summary: faker.lorem.slug(1),
      is_active: faker.datatype.boolean(),
      block_all: faker.datatype.boolean(),
      silence_activity: faker.datatype.boolean(),
      silence_notifications: faker.datatype.boolean(),
      reject_media: faker.datatype.boolean(),
    })),
  };
}

export function getModerationCreateInstancePolicy201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    target: {
      type: faker.helpers.arrayElement(["domain", "actor"]),
      id: faker.lorem.slug(1),
    },
    creation_date: faker.date.past(),
    actor: faker.internet.email(),
    summary: faker.lorem.slug(1),
    is_active: faker.datatype.boolean(),
    block_all: faker.datatype.boolean(),
    silence_activity: faker.datatype.boolean(),
    silence_notifications: faker.datatype.boolean(),
    reject_media: faker.datatype.boolean(),
  };
}

export function getModerationGetInstancePolicy200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    target: {
      type: faker.helpers.arrayElement(["domain", "actor"]),
      id: faker.lorem.slug(1),
    },
    creation_date: faker.date.past(),
    actor: faker.internet.email(),
    summary: faker.lorem.slug(1),
    is_active: faker.datatype.boolean(),
    block_all: faker.datatype.boolean(),
    silence_activity: faker.datatype.boolean(),
    silence_notifications: faker.datatype.boolean(),
    reject_media: faker.datatype.boolean(),
  };
}

export function getModerationUpdateInstancePolicy200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    target: {
      type: faker.helpers.arrayElement(["domain", "actor"]),
      id: faker.lorem.slug(1),
    },
    creation_date: faker.date.past(),
    actor: faker.internet.email(),
    summary: faker.lorem.slug(1),
    is_active: faker.datatype.boolean(),
    block_all: faker.datatype.boolean(),
    silence_activity: faker.datatype.boolean(),
    silence_notifications: faker.datatype.boolean(),
    reject_media: faker.datatype.boolean(),
  };
}

export function getModerationPartialUpdateInstancePolicy200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    target: {
      type: faker.helpers.arrayElement(["domain", "actor"]),
      id: faker.lorem.slug(1),
    },
    creation_date: faker.date.past(),
    actor: faker.internet.email(),
    summary: faker.lorem.slug(1),
    is_active: faker.datatype.boolean(),
    block_all: faker.datatype.boolean(),
    silence_activity: faker.datatype.boolean(),
    silence_notifications: faker.datatype.boolean(),
    reject_media: faker.datatype.boolean(),
  };
}

export function getModerationGetNotes200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      author: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    })),
  };
}

export function getModerationCreateNote201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    creation_date: faker.date.past(),
    summary: faker.lorem.slug(1),
    author: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getModerationGetNote200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    creation_date: faker.date.past(),
    summary: faker.lorem.slug(1),
    author: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getModerationGetReports200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      fid: faker.internet.url(),
      creation_date: faker.date.past(),
      handled_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "takedown_request",
        "invalid_metadata",
        "illegal_content",
        "offensive_content",
        "other",
      ]),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target_state: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      is_handled: faker.datatype.boolean(),
      assigned_to: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      target_owner: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      submitter: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
      submitter_email: faker.internet.email(),
      notes: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int({ min: undefined, max: undefined }),
        uuid: faker.datatype.uuid(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        author: {
          id: faker.number.int({ min: undefined, max: undefined }),
          url: faker.internet.url(),
          fid: faker.internet.url(),
          preferred_username: faker.person.fullName(),
          full_username: faker.person.fullName(),
          domain: faker.lorem.slug(1),
          name: faker.person.fullName(),
          summary: faker.lorem.slug(1),
          type: faker.helpers.arrayElement([
            "Person",
            "Tombstone",
            "Application",
            "Group",
            "Organization",
            "Service",
          ]),
          creation_date: faker.date.past(),
          last_fetch_date: faker.date.past(),
          inbox_url: faker.internet.url(),
          outbox_url: faker.internet.url(),
          shared_inbox_url: faker.internet.url(),
          manually_approves_followers: faker.datatype.boolean(),
          is_local: faker.datatype.boolean(),
        },
      })),
    })),
  };
}

export function getModerationGetReport200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    creation_date: faker.date.past(),
    handled_date: faker.date.past(),
    summary: faker.lorem.slug(1),
    type: faker.helpers.arrayElement([
      "takedown_request",
      "invalid_metadata",
      "illegal_content",
      "offensive_content",
      "other",
    ]),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    is_handled: faker.datatype.boolean(),
    assigned_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    target_owner: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    submitter: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    submitter_email: faker.internet.email(),
    notes: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      author: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
    })),
  };
}

export function getModerationUpdateReport200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    creation_date: faker.date.past(),
    handled_date: faker.date.past(),
    summary: faker.lorem.slug(1),
    type: faker.helpers.arrayElement([
      "takedown_request",
      "invalid_metadata",
      "illegal_content",
      "offensive_content",
      "other",
    ]),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    is_handled: faker.datatype.boolean(),
    assigned_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    target_owner: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    submitter: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    submitter_email: faker.internet.email(),
    notes: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      author: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
    })),
  };
}

export function getModerationPartialUpdateReport200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    uuid: faker.datatype.uuid(),
    fid: faker.internet.url(),
    creation_date: faker.date.past(),
    handled_date: faker.date.past(),
    summary: faker.lorem.slug(1),
    type: faker.helpers.arrayElement([
      "takedown_request",
      "invalid_metadata",
      "illegal_content",
      "offensive_content",
      "other",
    ]),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    is_handled: faker.datatype.boolean(),
    assigned_to: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    target_owner: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    submitter: {
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      fid: faker.internet.url(),
      preferred_username: faker.person.fullName(),
      full_username: faker.person.fullName(),
      domain: faker.lorem.slug(1),
      name: faker.person.fullName(),
      summary: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      creation_date: faker.date.past(),
      last_fetch_date: faker.date.past(),
      inbox_url: faker.internet.url(),
      outbox_url: faker.internet.url(),
      shared_inbox_url: faker.internet.url(),
      manually_approves_followers: faker.datatype.boolean(),
      is_local: faker.datatype.boolean(),
    },
    submitter_email: faker.internet.email(),
    notes: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      uuid: faker.datatype.uuid(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      author: {
        id: faker.number.int({ min: undefined, max: undefined }),
        url: faker.internet.url(),
        fid: faker.internet.url(),
        preferred_username: faker.person.fullName(),
        full_username: faker.person.fullName(),
        domain: faker.lorem.slug(1),
        name: faker.person.fullName(),
        summary: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        creation_date: faker.date.past(),
        last_fetch_date: faker.date.past(),
        inbox_url: faker.internet.url(),
        outbox_url: faker.internet.url(),
        shared_inbox_url: faker.internet.url(),
        manually_approves_followers: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
      },
    })),
  };
}

export function getModerationGetRequests200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      upload_quota: faker.number.int({ min: undefined, max: undefined }),
    })),
  };
}

export function getModerationGetRequest200Response() {
  return {
    name: faker.person.fullName(),
    is_active: faker.datatype.boolean(),
    is_staff: faker.datatype.boolean(),
    is_superuser: faker.datatype.boolean(),
    upload_quota: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getModerationUpdateRequest200Response() {
  return {
    name: faker.person.fullName(),
    is_active: faker.datatype.boolean(),
    is_staff: faker.datatype.boolean(),
    is_superuser: faker.datatype.boolean(),
    upload_quota: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getModerationPartialUpdateRequest200Response() {
  return {
    name: faker.person.fullName(),
    is_active: faker.datatype.boolean(),
    is_staff: faker.datatype.boolean(),
    is_superuser: faker.datatype.boolean(),
    upload_quota: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getAdminGetTags200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      albums_count: faker.number.int({ min: undefined, max: undefined }),
      artists_count: faker.number.int({ min: undefined, max: undefined }),
    })),
  };
}

export function getAdminCreateTag201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    albums_count: faker.number.int({ min: undefined, max: undefined }),
    artists_count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getAdminGetTag200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    albums_count: faker.number.int({ min: undefined, max: undefined }),
    artists_count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getAdminCreateTagAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    albums_count: faker.number.int({ min: undefined, max: undefined }),
    artists_count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getAdminGetInvitations200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      owner: {
        id: faker.number.int({ min: undefined, max: undefined }),
        username: faker.person.fullName(),
        email: faker.internet.email(),
        name: faker.person.fullName(),
        is_active: faker.datatype.boolean(),
        is_staff: faker.datatype.boolean(),
        is_superuser: faker.datatype.boolean(),
        date_joined: faker.date.past(),
        last_activity: faker.date.past(),
        privacy_level: faker.helpers.arrayElement([
          "me",
          "followers",
          "instance",
          "everyone",
        ]),
        upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
      },
      invited_user: {
        id: faker.number.int({ min: undefined, max: undefined }),
        username: faker.person.fullName(),
        email: faker.internet.email(),
        name: faker.person.fullName(),
        is_active: faker.datatype.boolean(),
        is_staff: faker.datatype.boolean(),
        is_superuser: faker.datatype.boolean(),
        date_joined: faker.date.past(),
        last_activity: faker.date.past(),
        privacy_level: faker.helpers.arrayElement([
          "me",
          "followers",
          "instance",
          "everyone",
        ]),
        upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
      },
      code: faker.lorem.slug(1),
      expiration_date: faker.date.past(),
      creation_date: faker.date.past(),
      users: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int({ min: undefined, max: undefined }),
        username: faker.person.fullName(),
        email: faker.internet.email(),
        name: faker.person.fullName(),
        is_active: faker.datatype.boolean(),
        is_staff: faker.datatype.boolean(),
        is_superuser: faker.datatype.boolean(),
        date_joined: faker.date.past(),
        last_activity: faker.date.past(),
        privacy_level: faker.helpers.arrayElement([
          "me",
          "followers",
          "instance",
          "everyone",
        ]),
        upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
      })),
    })),
  };
}

export function getAdminCreateInvitation201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    owner: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    invited_user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    code: faker.lorem.slug(1),
    expiration_date: faker.date.past(),
    creation_date: faker.date.past(),
    users: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    })),
  };
}

export function getAdminGetInvitation200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    owner: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    invited_user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    code: faker.lorem.slug(1),
    expiration_date: faker.date.past(),
    creation_date: faker.date.past(),
    users: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    })),
  };
}

export function getAdminUpdateInvitation200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    owner: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    invited_user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    code: faker.lorem.slug(1),
    expiration_date: faker.date.past(),
    creation_date: faker.date.past(),
    users: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    })),
  };
}

export function getAdminPartialUpdateInvitation200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    owner: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    invited_user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    code: faker.lorem.slug(1),
    expiration_date: faker.date.past(),
    creation_date: faker.date.past(),
    users: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    })),
  };
}

export function getAdminCreateInvitationAction200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    owner: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    invited_user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    },
    code: faker.lorem.slug(1),
    expiration_date: faker.date.past(),
    creation_date: faker.date.past(),
    users: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: 0, max: 2147483647 }),
    })),
  };
}

export function getAdminGetUsers200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      actor: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      email: faker.internet.email(),
      name: faker.person.fullName(),
      is_active: faker.datatype.boolean(),
      is_staff: faker.datatype.boolean(),
      is_superuser: faker.datatype.boolean(),
      date_joined: faker.date.past(),
      last_activity: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      upload_quota: faker.number.int({ min: undefined, max: undefined }),
      full_username: faker.person.fullName(),
    })),
  };
}

export function getAdminGetUser200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    username: faker.person.fullName(),
    actor: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    email: faker.internet.email(),
    name: faker.person.fullName(),
    is_active: faker.datatype.boolean(),
    is_staff: faker.datatype.boolean(),
    is_superuser: faker.datatype.boolean(),
    date_joined: faker.date.past(),
    last_activity: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    upload_quota: faker.number.int({ min: undefined, max: undefined }),
    full_username: faker.person.fullName(),
  };
}

export function getAdminUpdateUser200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    username: faker.person.fullName(),
    actor: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    email: faker.internet.email(),
    name: faker.person.fullName(),
    is_active: faker.datatype.boolean(),
    is_staff: faker.datatype.boolean(),
    is_superuser: faker.datatype.boolean(),
    date_joined: faker.date.past(),
    last_activity: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    upload_quota: faker.number.int({ min: undefined, max: undefined }),
    full_username: faker.person.fullName(),
  };
}

export function getAdminPartialUpdateUser200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    username: faker.person.fullName(),
    actor: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    email: faker.internet.email(),
    name: faker.person.fullName(),
    is_active: faker.datatype.boolean(),
    is_staff: faker.datatype.boolean(),
    is_superuser: faker.datatype.boolean(),
    date_joined: faker.date.past(),
    last_activity: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    upload_quota: faker.number.int({ min: undefined, max: undefined }),
    full_username: faker.person.fullName(),
  };
}

export function getGetModerationContentFilters200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.datatype.uuid(),
      target: {
        type: faker.helpers.arrayElement(["artist"]),
        id: faker.lorem.slug(1),
      },
      creation_date: faker.date.past(),
    })),
  };
}

export function getCreateModerationContentFilter201Response() {
  return {
    uuid: faker.datatype.uuid(),
    target: {
      type: faker.helpers.arrayElement(["artist"]),
      id: faker.lorem.slug(1),
    },
    creation_date: faker.date.past(),
  };
}

export function getGetModerationContentFilter200Response() {
  return {
    uuid: faker.datatype.uuid(),
    target: {
      type: faker.helpers.arrayElement(["artist"]),
      id: faker.lorem.slug(1),
    },
    creation_date: faker.date.past(),
  };
}

export function getCreateModerationReport201Response() {
  return {
    uuid: faker.datatype.uuid(),
    summary: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    handled_date: faker.date.past(),
    is_handled: faker.datatype.boolean(),
    submitter_email: faker.internet.email(),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    type: faker.helpers.arrayElement([
      "takedown_request",
      "invalid_metadata",
      "illegal_content",
      "offensive_content",
      "other",
    ]),
  };
}

export function getGetMutations200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      fid: faker.internet.url(),
      uuid: faker.datatype.uuid(),
      type: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      applied_date: faker.date.past(),
      is_approved: faker.datatype.boolean(),
      is_applied: faker.datatype.boolean(),
      created_by: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      approved_by: faker.number.int({ min: undefined, max: undefined }),
      summary: faker.lorem.slug(1),
      payload: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      previous_state: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    })),
  };
}

export function getGetMutation200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    type: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    applied_date: faker.date.past(),
    is_approved: faker.datatype.boolean(),
    is_applied: faker.datatype.boolean(),
    created_by: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    approved_by: faker.number.int({ min: undefined, max: undefined }),
    summary: faker.lorem.slug(1),
    payload: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    previous_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getApproveMutation200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    type: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    applied_date: faker.date.past(),
    is_approved: faker.datatype.boolean(),
    is_applied: faker.datatype.boolean(),
    created_by: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    approved_by: faker.number.int({ min: undefined, max: undefined }),
    summary: faker.lorem.slug(1),
    payload: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    previous_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getRejectMutation200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    type: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    applied_date: faker.date.past(),
    is_approved: faker.datatype.boolean(),
    is_applied: faker.datatype.boolean(),
    created_by: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    approved_by: faker.number.int({ min: undefined, max: undefined }),
    summary: faker.lorem.slug(1),
    payload: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    previous_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetOauthApps200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      client_id: faker.lorem.slug(1),
      name: faker.person.fullName(),
      scopes: faker.lorem.slug(1),
      created: faker.date.past(),
      updated: faker.date.past(),
    })),
  };
}

export function getCreateOauthApp201Response() {
  return {
    client_id: faker.lorem.slug(1),
    name: faker.person.fullName(),
    scopes: faker.lorem.slug(1),
    client_secret: faker.lorem.slug(1),
    created: faker.date.past(),
    updated: faker.date.past(),
    redirect_uris: faker.lorem.slug(1),
  };
}

export function getGetOauthApp200Response() {
  return {
    client_id: faker.lorem.slug(1),
    name: faker.person.fullName(),
    scopes: faker.lorem.slug(1),
    created: faker.date.past(),
    updated: faker.date.past(),
  };
}

export function getUpdateOauthApp200Response() {
  return {
    client_id: faker.lorem.slug(1),
    name: faker.person.fullName(),
    scopes: faker.lorem.slug(1),
    created: faker.date.past(),
    updated: faker.date.past(),
  };
}

export function getPartialUpdateOauthApp200Response() {
  return {
    client_id: faker.lorem.slug(1),
    name: faker.person.fullName(),
    scopes: faker.lorem.slug(1),
    created: faker.date.past(),
    updated: faker.date.past(),
  };
}

export function getRefreshOauthToken200Response() {
  return {
    client_id: faker.lorem.slug(1),
    name: faker.person.fullName(),
    scopes: faker.lorem.slug(1),
    client_secret: faker.lorem.slug(1),
    created: faker.date.past(),
    updated: faker.date.past(),
    redirect_uris: faker.lorem.slug(1),
  };
}

export function getGetOauthGrants200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    client_id: faker.lorem.slug(1),
    name: faker.person.fullName(),
    scopes: faker.lorem.slug(1),
    created: faker.date.past(),
    updated: faker.date.past(),
  }));
}

export function getGetOauthGrant200Response() {
  return {
    client_id: faker.lorem.slug(1),
    name: faker.person.fullName(),
    scopes: faker.lorem.slug(1),
    created: faker.date.past(),
    updated: faker.date.past(),
  };
}

export function getGetOembed200Response() {
  return {
    format: faker.helpers.arrayElement(["json"]),
    url: faker.internet.url(),
    maxheight: faker.number.int({ min: undefined, max: undefined }),
    maxwidth: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getGetPlaylists200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      name: faker.person.fullName(),
      user: {
        id: faker.number.int({ min: undefined, max: undefined }),
        username: faker.person.fullName(),
        name: faker.person.fullName(),
        date_joined: faker.date.past(),
        avatar: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
      },
      modification_date: faker.date.past(),
      creation_date: faker.date.past(),
      privacy_level: faker.helpers.arrayElement([
        "me",
        "followers",
        "instance",
        "everyone",
      ]),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      album_covers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      duration: faker.number.int({ min: undefined, max: undefined }),
      is_playable: faker.datatype.boolean(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
    })),
  };
}

export function getCreatePlaylist201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    modification_date: faker.date.past(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    album_covers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    duration: faker.number.int({ min: undefined, max: undefined }),
    is_playable: faker.datatype.boolean(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getGetPlaylist200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    modification_date: faker.date.past(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    album_covers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    duration: faker.number.int({ min: undefined, max: undefined }),
    is_playable: faker.datatype.boolean(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getUpdatePlaylist200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    modification_date: faker.date.past(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    album_covers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    duration: faker.number.int({ min: undefined, max: undefined }),
    is_playable: faker.datatype.boolean(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getPartialUpdatePlaylist200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    modification_date: faker.date.past(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    album_covers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    duration: faker.number.int({ min: undefined, max: undefined }),
    is_playable: faker.datatype.boolean(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getAddToPlaylist200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    modification_date: faker.date.past(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    album_covers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    duration: faker.number.int({ min: undefined, max: undefined }),
    is_playable: faker.datatype.boolean(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getReorderTrackInPlaylist200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    modification_date: faker.date.past(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    album_covers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    duration: faker.number.int({ min: undefined, max: undefined }),
    is_playable: faker.datatype.boolean(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getRemoveFromPlaylist2200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    name: faker.person.fullName(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    modification_date: faker.date.past(),
    creation_date: faker.date.past(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    tracks_count: faker.number.int({ min: undefined, max: undefined }),
    album_covers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    duration: faker.number.int({ min: undefined, max: undefined }),
    is_playable: faker.datatype.boolean(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
  };
}

export function getGetPlaylistTracks200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      track: faker.lorem.slug(1),
      index: faker.number.int({ min: 0, max: 2147483647 }),
      creation_date: faker.date.past(),
    })),
  };
}

export function getGetRadios200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      is_public: faker.datatype.boolean(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      user: {
        id: faker.number.int({ min: undefined, max: undefined }),
        username: faker.person.fullName(),
        name: faker.person.fullName(),
        date_joined: faker.date.past(),
        avatar: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
      },
      config: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      description: faker.lorem.slug(1),
    })),
  };
}

export function getCreateRadio201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    is_public: faker.datatype.boolean(),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    config: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    description: faker.lorem.slug(1),
  };
}

export function getGetRadio200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    is_public: faker.datatype.boolean(),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    config: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    description: faker.lorem.slug(1),
  };
}

export function getUpdateRadio200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    is_public: faker.datatype.boolean(),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    config: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    description: faker.lorem.slug(1),
  };
}

export function getPartialUpdateRadio200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    is_public: faker.datatype.boolean(),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    config: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    description: faker.lorem.slug(1),
  };
}

export function getGetRadioTrack200Response() {
  return {
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      content_category: faker.helpers.arrayElement([
        "music",
        "podcast",
        "other",
      ]),
      description: {
        text: faker.lorem.slug(1),
        content_type: faker.helpers.arrayElement([
          "text/html",
          "text/markdown",
          "text/plain",
        ]),
        html: faker.lorem.slug(1),
      },
      attachment_cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.datatype.uuid(),
    },
    album: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      release_date: faker.date.past(),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
    },
    uploads: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.datatype.uuid(),
      listen_url: faker.internet.url(),
      size: faker.number.int({ min: undefined, max: undefined }),
      duration: faker.number.int({ min: undefined, max: undefined }),
      bitrate: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      extension: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
    })),
    listen_url: faker.internet.url(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    is_local: faker.datatype.boolean(),
    position: faker.number.int({ min: undefined, max: undefined }),
    disc_number: faker.number.int({ min: undefined, max: undefined }),
    downloads_count: faker.number.int({ min: undefined, max: undefined }),
    copyright: faker.lorem.slug(1),
    license: faker.lorem.slug(1),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    is_playable: faker.datatype.boolean(),
  };
}

export function getGetRadioFilter200Response() {
  return {
    type: faker.lorem.slug(1),
    label: faker.lorem.slug(1),
    help_text: faker.lorem.slug(1),
    fields: faker.lorem.slug(1),
  };
}

export function getValidateRadio200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    is_public: faker.datatype.boolean(),
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
    user: {
      id: faker.number.int({ min: undefined, max: undefined }),
      username: faker.person.fullName(),
      name: faker.person.fullName(),
      date_joined: faker.date.past(),
      avatar: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    },
    config: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    description: faker.lorem.slug(1),
  };
}

export function getCreateRadioSession201Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    radio_type: faker.lorem.slug(1),
    related_object_id: faker.lorem.slug(1),
    user: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
    custom_radio: faker.number.int({ min: undefined, max: undefined }),
    config: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetRadioSession200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    radio_type: faker.lorem.slug(1),
    related_object_id: faker.lorem.slug(1),
    user: faker.number.int({ min: undefined, max: undefined }),
    creation_date: faker.date.past(),
    custom_radio: faker.number.int({ min: undefined, max: undefined }),
    config: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetNextRadioTrack201Response() {
  return {
    session: faker.number.int({ min: undefined, max: undefined }),
    count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getGetRateLimit200Response() {
  return {
    enabled: faker.datatype.boolean(),
    ident: {
      type: faker.lorem.slug(1),
      id: faker.lorem.slug(1),
    },
    scopes: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.lorem.slug(1),
      rate: faker.lorem.slug(1),
      description: faker.lorem.slug(1),
      limit: faker.number.int({ min: undefined, max: undefined }),
      duration: faker.number.int({ min: undefined, max: undefined }),
      remaining: faker.number.int({ min: undefined, max: undefined }),
      available: faker.number.int({ min: undefined, max: undefined }),
      available_seconds: faker.number.int({ min: undefined, max: undefined }),
      reset: faker.number.int({ min: undefined, max: undefined }),
      reset_seconds: faker.number.int({ min: undefined, max: undefined }),
    })),
  };
}

export function getGetSearchResults200Response() {
  return {
    artists: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      albums: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        is_playable: faker.datatype.boolean(),
        is_local: faker.datatype.boolean(),
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: faker.number.int({ min: undefined, max: undefined }),
        release_date: faker.date.past(),
        creation_date: faker.date.past(),
      })),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      channel: {
        uuid: faker.lorem.slug(1),
        actor: {
          full_username: faker.person.fullName(),
          preferred_username: faker.person.fullName(),
          domain: faker.lorem.slug(1),
        },
      },
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      content_category: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
    })),
    tracks: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
      },
      uploads: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.datatype.uuid(),
        listen_url: faker.internet.url(),
        size: faker.number.int({ min: undefined, max: undefined }),
        duration: faker.number.int({ min: undefined, max: undefined }),
        bitrate: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        extension: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      })),
      listen_url: faker.internet.url(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      position: faker.number.int({ min: undefined, max: undefined }),
      disc_number: faker.number.int({ min: undefined, max: undefined }),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
    })),
    albums: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      release_date: faker.date.past(),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      duration: faker.number.int({ min: undefined, max: undefined }),
    })),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
    })),
  };
}

export function getGetTrackStream200Response() {
  return null;
}

export function getGetSubscriptions200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      approved: faker.datatype.boolean(),
      fid: faker.internet.url(),
      uuid: faker.datatype.uuid(),
      creation_date: faker.date.past(),
    })),
  };
}

export function getGetSubscription200Response() {
  return {
    approved: faker.datatype.boolean(),
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    creation_date: faker.date.past(),
  };
}

export function getGetAllSubscriptions200Response() {
  return {
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.datatype.uuid(),
      channel: faker.datatype.uuid(),
    })),
    count: faker.number.int({ min: undefined, max: undefined }),
  };
}

export function getGetTags200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
    })),
  };
}

export function getGetTag200Response() {
  return {
    name: faker.person.fullName(),
    creation_date: faker.date.past(),
  };
}

export function getPreviewText200Response() {
  return {
    rendered: faker.lorem.slug(1),
  };
}

export function getPreviewText400Response() {
  return {
    detail: faker.lorem.slug(1),
  };
}

export function getGetTracks200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
      },
      uploads: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.datatype.uuid(),
        listen_url: faker.internet.url(),
        size: faker.number.int({ min: undefined, max: undefined }),
        duration: faker.number.int({ min: undefined, max: undefined }),
        bitrate: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        extension: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      })),
      listen_url: faker.internet.url(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      position: faker.number.int({ min: undefined, max: undefined }),
      disc_number: faker.number.int({ min: undefined, max: undefined }),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
    })),
  };
}

export function getGetTrack200Response() {
  return {
    artist: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      name: faker.person.fullName(),
      creation_date: faker.date.past(),
      modification_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      content_category: faker.helpers.arrayElement([
        "music",
        "podcast",
        "other",
      ]),
      description: {
        text: faker.lorem.slug(1),
        content_type: faker.helpers.arrayElement([
          "text/html",
          "text/markdown",
          "text/plain",
        ]),
        html: faker.lorem.slug(1),
      },
      attachment_cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      channel: faker.datatype.uuid(),
    },
    album: {
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      release_date: faker.date.past(),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      tracks_count: faker.number.int({ min: undefined, max: undefined }),
    },
    uploads: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.datatype.uuid(),
      listen_url: faker.internet.url(),
      size: faker.number.int({ min: undefined, max: undefined }),
      duration: faker.number.int({ min: undefined, max: undefined }),
      bitrate: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      extension: faker.lorem.slug(1),
      is_local: faker.datatype.boolean(),
    })),
    listen_url: faker.internet.url(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.slug(1)),
    attributed_to: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    id: faker.number.int({ min: undefined, max: undefined }),
    fid: faker.internet.url(),
    mbid: faker.datatype.uuid(),
    title: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    is_local: faker.datatype.boolean(),
    position: faker.number.int({ min: undefined, max: undefined }),
    disc_number: faker.number.int({ min: undefined, max: undefined }),
    downloads_count: faker.number.int({ min: undefined, max: undefined }),
    copyright: faker.lorem.slug(1),
    license: faker.lorem.slug(1),
    cover: {
      uuid: faker.datatype.uuid(),
      size: faker.number.int({ min: undefined, max: undefined }),
      mimetype: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      urls: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    },
    is_playable: faker.datatype.boolean(),
  };
}

export function getGetTrackFetches200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int({ min: undefined, max: undefined }),
      url: faker.internet.url(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      status: faker.helpers.arrayElement([
        "pending",
        "errored",
        "finished",
        "skipped",
      ]),
      detail: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      creation_date: faker.date.past(),
      fetch_date: faker.date.past(),
    })),
  };
}

export function getCreateTrackFetch200Response() {
  return {
    id: faker.number.int({ min: undefined, max: undefined }),
    url: faker.internet.url(),
    actor: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    status: faker.helpers.arrayElement([
      "pending",
      "errored",
      "finished",
      "skipped",
    ]),
    detail: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    creation_date: faker.date.past(),
    fetch_date: faker.date.past(),
  };
}

export function getGetTrackLibraries200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      fid: faker.internet.url(),
      uuid: faker.datatype.uuid(),
      actor: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      name: faker.person.fullName(),
      description: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      uploads_count: faker.number.int({ min: undefined, max: undefined }),
      privacy_level: faker.helpers.arrayElement(["me", "instance", "everyone"]),
      follow: {
        creation_date: faker.date.past(),
        uuid: faker.datatype.uuid(),
        fid: faker.internet.url(),
        approved: faker.datatype.boolean(),
        modification_date: faker.date.past(),
      },
      latest_scan: {
        total_files: faker.number.int({ min: 0, max: 2147483647 }),
        processed_files: faker.number.int({ min: 0, max: 2147483647 }),
        errored_files: faker.number.int({ min: 0, max: 2147483647 }),
        status: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
      },
    })),
  };
}

export function getGetTrackMutations200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      fid: faker.internet.url(),
      uuid: faker.datatype.uuid(),
      type: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      applied_date: faker.date.past(),
      is_approved: faker.datatype.boolean(),
      is_applied: faker.datatype.boolean(),
      created_by: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      approved_by: faker.number.int({ min: undefined, max: undefined }),
      summary: faker.lorem.slug(1),
      payload: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      previous_state: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      target: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    })),
  };
}

export function getCreateTrackMutation200Response() {
  return {
    fid: faker.internet.url(),
    uuid: faker.datatype.uuid(),
    type: faker.lorem.slug(1),
    creation_date: faker.date.past(),
    applied_date: faker.date.past(),
    is_approved: faker.datatype.boolean(),
    is_applied: faker.datatype.boolean(),
    created_by: {
      fid: faker.internet.url(),
      url: faker.internet.url(),
      creation_date: faker.date.past(),
      summary: faker.lorem.slug(1),
      preferred_username: faker.person.fullName(),
      name: faker.person.fullName(),
      last_fetch_date: faker.date.past(),
      domain: faker.lorem.slug(1),
      type: faker.helpers.arrayElement([
        "Person",
        "Tombstone",
        "Application",
        "Group",
        "Organization",
        "Service",
      ]),
      manually_approves_followers: faker.datatype.boolean(),
      full_username: faker.person.fullName(),
      is_local: faker.datatype.boolean(),
    },
    approved_by: faker.number.int({ min: undefined, max: undefined }),
    summary: faker.lorem.slug(1),
    payload: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    previous_state: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    target: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  };
}

export function getGetUploads200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?page=4",
    previous: "http://api.example.org/accounts/?page=2",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.datatype.uuid(),
      filename: faker.person.fullName(),
      creation_date: faker.date.past(),
      mimetype: faker.lorem.slug(1),
      track: {
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        album: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          title: faker.lorem.slug(1),
          artist: {
            id: faker.number.int({ min: undefined, max: undefined }),
            fid: faker.internet.url(),
            mbid: faker.datatype.uuid(),
            name: faker.person.fullName(),
            creation_date: faker.date.past(),
            modification_date: faker.date.past(),
            is_local: faker.datatype.boolean(),
            content_category: faker.helpers.arrayElement([
              "music",
              "podcast",
              "other",
            ]),
            description: {
              text: faker.lorem.slug(1),
              content_type: faker.helpers.arrayElement([
                "text/html",
                "text/markdown",
                "text/plain",
              ]),
              html: faker.lorem.slug(1),
            },
            attachment_cover: {
              uuid: faker.datatype.uuid(),
              size: faker.number.int({ min: undefined, max: undefined }),
              mimetype: faker.lorem.slug(1),
              creation_date: faker.date.past(),
              urls: [...new Array(5).keys()]
                .map((_) => ({ [faker.lorem.word()]: null }))
                .reduce((acc, next) => Object.assign(acc, next), {}),
            },
            channel: faker.datatype.uuid(),
          },
          release_date: faker.date.past(),
          cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          creation_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          tracks_count: faker.number.int({ min: undefined, max: undefined }),
        },
        uploads: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.datatype.uuid(),
          listen_url: faker.internet.url(),
          size: faker.number.int({ min: undefined, max: undefined }),
          duration: faker.number.int({ min: undefined, max: undefined }),
          bitrate: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          extension: faker.lorem.slug(1),
          is_local: faker.datatype.boolean(),
        })),
        listen_url: faker.internet.url(),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.slug(1)),
        attributed_to: {
          fid: faker.internet.url(),
          url: faker.internet.url(),
          creation_date: faker.date.past(),
          summary: faker.lorem.slug(1),
          preferred_username: faker.person.fullName(),
          name: faker.person.fullName(),
          last_fetch_date: faker.date.past(),
          domain: faker.lorem.slug(1),
          type: faker.helpers.arrayElement([
            "Person",
            "Tombstone",
            "Application",
            "Group",
            "Organization",
            "Service",
          ]),
          manually_approves_followers: faker.datatype.boolean(),
          full_username: faker.person.fullName(),
          is_local: faker.datatype.boolean(),
        },
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        position: faker.number.int({ min: undefined, max: undefined }),
        disc_number: faker.number.int({ min: undefined, max: undefined }),
        downloads_count: faker.number.int({ min: undefined, max: undefined }),
        copyright: faker.lorem.slug(1),
        license: faker.lorem.slug(1),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        is_playable: faker.datatype.boolean(),
      },
      library: faker.lorem.slug(1),
      channel: faker.lorem.slug(1),
      duration: faker.number.int({ min: undefined, max: undefined }),
      bitrate: faker.number.int({ min: undefined, max: undefined }),
      size: faker.number.int({ min: undefined, max: undefined }),
      import_date: faker.date.past(),
      import_status: faker.helpers.arrayElement([
        "draft",
        "pending",
        "finished",
        "errored",
        "skipped",
      ]),
      import_details: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      import_metadata: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      import_reference: faker.lorem.slug(1),
      metadata: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      source: faker.lorem.slug(1),
    })),
  };
}

export function getCreateUpload201Response() {
  return {
    uuid: faker.datatype.uuid(),
    filename: faker.person.fullName(),
    creation_date: faker.date.past(),
    mimetype: faker.lorem.slug(1),
    track: {
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
      },
      uploads: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.datatype.uuid(),
        listen_url: faker.internet.url(),
        size: faker.number.int({ min: undefined, max: undefined }),
        duration: faker.number.int({ min: undefined, max: undefined }),
        bitrate: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        extension: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      })),
      listen_url: faker.internet.url(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      position: faker.number.int({ min: undefined, max: undefined }),
      disc_number: faker.number.int({ min: undefined, max: undefined }),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
    },
    library: faker.lorem.slug(1),
    channel: faker.lorem.slug(1),
    duration: faker.number.int({ min: undefined, max: undefined }),
    bitrate: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    import_date: faker.date.past(),
    import_status: faker.helpers.arrayElement([
      "draft",
      "pending",
      "finished",
      "errored",
      "skipped",
    ]),
    import_details: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_reference: faker.lorem.slug(1),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    source: faker.lorem.slug(1),
  };
}

export function getGetUpload200Response() {
  return {
    uuid: faker.datatype.uuid(),
    filename: faker.person.fullName(),
    creation_date: faker.date.past(),
    mimetype: faker.lorem.slug(1),
    track: {
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
      },
      uploads: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.datatype.uuid(),
        listen_url: faker.internet.url(),
        size: faker.number.int({ min: undefined, max: undefined }),
        duration: faker.number.int({ min: undefined, max: undefined }),
        bitrate: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        extension: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      })),
      listen_url: faker.internet.url(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      position: faker.number.int({ min: undefined, max: undefined }),
      disc_number: faker.number.int({ min: undefined, max: undefined }),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
    },
    library: faker.lorem.slug(1),
    channel: faker.lorem.slug(1),
    duration: faker.number.int({ min: undefined, max: undefined }),
    bitrate: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    import_date: faker.date.past(),
    import_status: faker.helpers.arrayElement([
      "draft",
      "pending",
      "finished",
      "errored",
      "skipped",
    ]),
    import_details: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_reference: faker.lorem.slug(1),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    source: faker.lorem.slug(1),
  };
}

export function getUpdateUpload200Response() {
  return {
    uuid: faker.datatype.uuid(),
    filename: faker.person.fullName(),
    creation_date: faker.date.past(),
    mimetype: faker.lorem.slug(1),
    track: {
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
      },
      uploads: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.datatype.uuid(),
        listen_url: faker.internet.url(),
        size: faker.number.int({ min: undefined, max: undefined }),
        duration: faker.number.int({ min: undefined, max: undefined }),
        bitrate: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        extension: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      })),
      listen_url: faker.internet.url(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      position: faker.number.int({ min: undefined, max: undefined }),
      disc_number: faker.number.int({ min: undefined, max: undefined }),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
    },
    library: faker.lorem.slug(1),
    channel: faker.lorem.slug(1),
    duration: faker.number.int({ min: undefined, max: undefined }),
    bitrate: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    import_date: faker.date.past(),
    import_status: faker.helpers.arrayElement([
      "draft",
      "pending",
      "finished",
      "errored",
      "skipped",
    ]),
    import_details: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_reference: faker.lorem.slug(1),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    source: faker.lorem.slug(1),
  };
}

export function getPartialUpdateUpload200Response() {
  return {
    uuid: faker.datatype.uuid(),
    filename: faker.person.fullName(),
    creation_date: faker.date.past(),
    mimetype: faker.lorem.slug(1),
    track: {
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
      },
      uploads: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.datatype.uuid(),
        listen_url: faker.internet.url(),
        size: faker.number.int({ min: undefined, max: undefined }),
        duration: faker.number.int({ min: undefined, max: undefined }),
        bitrate: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        extension: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      })),
      listen_url: faker.internet.url(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      position: faker.number.int({ min: undefined, max: undefined }),
      disc_number: faker.number.int({ min: undefined, max: undefined }),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
    },
    library: faker.lorem.slug(1),
    channel: faker.lorem.slug(1),
    duration: faker.number.int({ min: undefined, max: undefined }),
    bitrate: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    import_date: faker.date.past(),
    import_status: faker.helpers.arrayElement([
      "draft",
      "pending",
      "finished",
      "errored",
      "skipped",
    ]),
    import_details: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_reference: faker.lorem.slug(1),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    source: faker.lorem.slug(1),
  };
}

export function getGetUploadMetadata200Response() {
  return {
    title: faker.lorem.slug(1),
    position: faker.lorem.slug(1),
    disc_number: faker.lorem.slug(1),
    copyright: faker.lorem.slug(1),
    license: faker.lorem.slug(1),
    mbid: faker.datatype.uuid(),
    tags: faker.lorem.slug(1),
    description: faker.lorem.slug(1),
    album: faker.lorem.slug(1),
    artists: faker.lorem.slug(1),
    cover_data: faker.lorem.slug(1),
  };
}

export function getCreateUploadAction200Response() {
  return {
    uuid: faker.datatype.uuid(),
    filename: faker.person.fullName(),
    creation_date: faker.date.past(),
    mimetype: faker.lorem.slug(1),
    track: {
      artist: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        name: faker.person.fullName(),
        creation_date: faker.date.past(),
        modification_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        content_category: faker.helpers.arrayElement([
          "music",
          "podcast",
          "other",
        ]),
        description: {
          text: faker.lorem.slug(1),
          content_type: faker.helpers.arrayElement([
            "text/html",
            "text/markdown",
            "text/plain",
          ]),
          html: faker.lorem.slug(1),
        },
        attachment_cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        channel: faker.datatype.uuid(),
      },
      album: {
        id: faker.number.int({ min: undefined, max: undefined }),
        fid: faker.internet.url(),
        mbid: faker.datatype.uuid(),
        title: faker.lorem.slug(1),
        artist: {
          id: faker.number.int({ min: undefined, max: undefined }),
          fid: faker.internet.url(),
          mbid: faker.datatype.uuid(),
          name: faker.person.fullName(),
          creation_date: faker.date.past(),
          modification_date: faker.date.past(),
          is_local: faker.datatype.boolean(),
          content_category: faker.helpers.arrayElement([
            "music",
            "podcast",
            "other",
          ]),
          description: {
            text: faker.lorem.slug(1),
            content_type: faker.helpers.arrayElement([
              "text/html",
              "text/markdown",
              "text/plain",
            ]),
            html: faker.lorem.slug(1),
          },
          attachment_cover: {
            uuid: faker.datatype.uuid(),
            size: faker.number.int({ min: undefined, max: undefined }),
            mimetype: faker.lorem.slug(1),
            creation_date: faker.date.past(),
            urls: [...new Array(5).keys()]
              .map((_) => ({ [faker.lorem.word()]: null }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
          },
          channel: faker.datatype.uuid(),
        },
        release_date: faker.date.past(),
        cover: {
          uuid: faker.datatype.uuid(),
          size: faker.number.int({ min: undefined, max: undefined }),
          mimetype: faker.lorem.slug(1),
          creation_date: faker.date.past(),
          urls: [...new Array(5).keys()]
            .map((_) => ({ [faker.lorem.word()]: null }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
        },
        creation_date: faker.date.past(),
        is_local: faker.datatype.boolean(),
        tracks_count: faker.number.int({ min: undefined, max: undefined }),
      },
      uploads: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.datatype.uuid(),
        listen_url: faker.internet.url(),
        size: faker.number.int({ min: undefined, max: undefined }),
        duration: faker.number.int({ min: undefined, max: undefined }),
        bitrate: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        extension: faker.lorem.slug(1),
        is_local: faker.datatype.boolean(),
      })),
      listen_url: faker.internet.url(),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.slug(1)),
      attributed_to: {
        fid: faker.internet.url(),
        url: faker.internet.url(),
        creation_date: faker.date.past(),
        summary: faker.lorem.slug(1),
        preferred_username: faker.person.fullName(),
        name: faker.person.fullName(),
        last_fetch_date: faker.date.past(),
        domain: faker.lorem.slug(1),
        type: faker.helpers.arrayElement([
          "Person",
          "Tombstone",
          "Application",
          "Group",
          "Organization",
          "Service",
        ]),
        manually_approves_followers: faker.datatype.boolean(),
        full_username: faker.person.fullName(),
        is_local: faker.datatype.boolean(),
      },
      id: faker.number.int({ min: undefined, max: undefined }),
      fid: faker.internet.url(),
      mbid: faker.datatype.uuid(),
      title: faker.lorem.slug(1),
      creation_date: faker.date.past(),
      is_local: faker.datatype.boolean(),
      position: faker.number.int({ min: undefined, max: undefined }),
      disc_number: faker.number.int({ min: undefined, max: undefined }),
      downloads_count: faker.number.int({ min: undefined, max: undefined }),
      copyright: faker.lorem.slug(1),
      license: faker.lorem.slug(1),
      cover: {
        uuid: faker.datatype.uuid(),
        size: faker.number.int({ min: undefined, max: undefined }),
        mimetype: faker.lorem.slug(1),
        creation_date: faker.date.past(),
        urls: [...new Array(5).keys()]
          .map((_) => ({ [faker.lorem.word()]: null }))
          .reduce((acc, next) => Object.assign(acc, next), {}),
      },
      is_playable: faker.datatype.boolean(),
    },
    library: faker.lorem.slug(1),
    channel: faker.lorem.slug(1),
    duration: faker.number.int({ min: undefined, max: undefined }),
    bitrate: faker.number.int({ min: undefined, max: undefined }),
    size: faker.number.int({ min: undefined, max: undefined }),
    import_date: faker.date.past(),
    import_status: faker.helpers.arrayElement([
      "draft",
      "pending",
      "finished",
      "errored",
      "skipped",
    ]),
    import_details: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    import_reference: faker.lorem.slug(1),
    metadata: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: null }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    source: faker.lorem.slug(1),
  };
}

export function getUpdateUser200Response() {
  return {
    name: faker.person.fullName(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    instance_support_message_display_date: faker.date.past(),
    funkwhale_support_message_display_date: faker.date.past(),
    summary: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
  };
}

export function getPartialUpdateUser200Response() {
  return {
    name: faker.person.fullName(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    instance_support_message_display_date: faker.date.past(),
    funkwhale_support_message_display_date: faker.date.past(),
    summary: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
  };
}

export function getGetUserSubsonicToken200Response() {
  return {
    name: faker.person.fullName(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    instance_support_message_display_date: faker.date.past(),
    funkwhale_support_message_display_date: faker.date.past(),
    summary: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
  };
}

export function getCreateUserSubsonicToken200Response() {
  return {
    name: faker.person.fullName(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    instance_support_message_display_date: faker.date.past(),
    funkwhale_support_message_display_date: faker.date.past(),
    summary: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
  };
}

export function getGetAuthenticatedUser200Response() {
  return {
    name: faker.person.fullName(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    instance_support_message_display_date: faker.date.past(),
    funkwhale_support_message_display_date: faker.date.past(),
    summary: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
  };
}

export function getUpdateSettings200Response() {
  return {
    name: faker.person.fullName(),
    privacy_level: faker.helpers.arrayElement([
      "me",
      "followers",
      "instance",
      "everyone",
    ]),
    instance_support_message_display_date: faker.date.past(),
    funkwhale_support_message_display_date: faker.date.past(),
    summary: {
      text: faker.lorem.slug(1),
      content_type: faker.helpers.arrayElement([
        "text/html",
        "text/markdown",
        "text/plain",
      ]),
      html: faker.lorem.slug(1),
    },
  };
}

// This configures a Service Worker with the given request handlers.
export const startWorker = () => {
  const server = setupServer(...handlers);
  server.listen();
};
